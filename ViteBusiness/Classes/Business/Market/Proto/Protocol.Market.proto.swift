// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: market.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct DexProtocol {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Identify a single client
  var clientID: String = String()

  ///见下面
  var topics: String = String()

  /// sub,un_sub,ping,pong,push
  var opType: String = String()

  ///proto数据
  var message: Data = SwiftProtobuf.Internal.emptyData

  ///错误编码 0:normal, 1:illegal_client_id，2:illegal_topics，3:illegal_op_type,5:visit_limit
  var errorCode: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

public struct TickerStatisticsProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///symbol
  public var symbol: String = String()

  ///symbol
  var tradeTokenSymbol: String = String()

  ///symbol
  var quoteTokenSymbol: String = String()

  ///tokenId
  var tradeToken: String = String()

  ///tokenId
  var quoteToken: String = String()

  ///价格
  var openPrice: String = String()

  ///价格
  var prevClosePrice: String = String()

  ///价格
  var closePrice: String = String()

  ///价格
  var priceChange: String = String()

  ///变化率
  var priceChangePercent: String = String()

  ///价格
  var highPrice: String = String()

  ///价格
  var lowPrice: String = String()

  ///数量
  var quantity: String = String()

  ///成交额
  var amount: String = String()

  ///price精度
  var pricePrecision: Int32 = 0

  ///quantity精度
  var quantityPrecision: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

struct TradeListProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var trade: [TradeProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TradeProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tradeID: String = String()

  ///symbol
  var symbol: String = String()

  ///symbol
  var tradeTokenSymbol: String = String()

  ///symbol
  var quoteTokenSymbol: String = String()

  ///tokenId
  var tradeToken: String = String()

  ///tokenId
  var quoteToken: String = String()

  ///price
  var price: String = String()

  ///quantity
  var quantity: String = String()

  ///amount
  var amount: String = String()

  ///time
  var time: Int64 = 0

  ///side
  var side: Int32 = 0

  ///orderId
  var buyerOrderID: String = String()

  ///orderId
  var sellerOrderID: String = String()

  ///fee
  var buyFee: String = String()

  ///fee
  var sellFee: String = String()

  ///height
  var blockHeight: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct KlineProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var t: Int64 = 0

  var c: Double = 0

  var o: Double = 0

  var h: Double = 0

  var l: Double = 0

  var v: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct OrderProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///订单ID
  var orderID: String {
    get {return _storage._orderID}
    set {_uniqueStorage()._orderID = newValue}
  }

  ///symbol
  var symbol: String {
    get {return _storage._symbol}
    set {_uniqueStorage()._symbol = newValue}
  }

  ///symbol
  var tradeTokenSymbol: String {
    get {return _storage._tradeTokenSymbol}
    set {_uniqueStorage()._tradeTokenSymbol = newValue}
  }

  ///symbol
  var quoteTokenSymbol: String {
    get {return _storage._quoteTokenSymbol}
    set {_uniqueStorage()._quoteTokenSymbol = newValue}
  }

  ///tokenId
  var tradeToken: String {
    get {return _storage._tradeToken}
    set {_uniqueStorage()._tradeToken = newValue}
  }

  ///tokenId
  var quoteToken: String {
    get {return _storage._quoteToken}
    set {_uniqueStorage()._quoteToken = newValue}
  }

  ///方向
  var side: Int32 {
    get {return _storage._side}
    set {_uniqueStorage()._side = newValue}
  }

  ///价格
  var price: String {
    get {return _storage._price}
    set {_uniqueStorage()._price = newValue}
  }

  ///数量
  var quantity: String {
    get {return _storage._quantity}
    set {_uniqueStorage()._quantity = newValue}
  }

  ///交易量
  var amount: String {
    get {return _storage._amount}
    set {_uniqueStorage()._amount = newValue}
  }

  ///成交Quantity
  var executedQuantity: String {
    get {return _storage._executedQuantity}
    set {_uniqueStorage()._executedQuantity = newValue}
  }

  ///成交Amount
  var executedAmount: String {
    get {return _storage._executedAmount}
    set {_uniqueStorage()._executedAmount = newValue}
  }

  ///成交率
  var executedPercent: String {
    get {return _storage._executedPercent}
    set {_uniqueStorage()._executedPercent = newValue}
  }

  ///均价
  var executedAvgPrice: String {
    get {return _storage._executedAvgPrice}
    set {_uniqueStorage()._executedAvgPrice = newValue}
  }

  ///手续费
  var fee: String {
    get {return _storage._fee}
    set {_uniqueStorage()._fee = newValue}
  }

  ///状态
  var status: Int32 {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  ///类型
  var type: Int32 {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///时间
  var createTime: Int64 {
    get {return _storage._createTime}
    set {_uniqueStorage()._createTime = newValue}
  }

  ///地址
  var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  ///订单hash
  var orderHash: String {
    get {return _storage._orderHash}
    set {_uniqueStorage()._orderHash = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct DepthListProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var asks: [DepthProto] = []

  var bids: [DepthProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DepthProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///价格
  var price: String = String()

  ///数量
  var quantity: String = String()

  ///交易量
  var amount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension DexProtocol: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DexProtocol"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .same(proto: "topics"),
    3: .standard(proto: "op_type"),
    4: .same(proto: "message"),
    5: .standard(proto: "error_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.clientID)
      case 2: try decoder.decodeSingularStringField(value: &self.topics)
      case 3: try decoder.decodeSingularStringField(value: &self.opType)
      case 4: try decoder.decodeSingularBytesField(value: &self.message)
      case 5: try decoder.decodeSingularInt32Field(value: &self.errorCode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if !self.topics.isEmpty {
      try visitor.visitSingularStringField(value: self.topics, fieldNumber: 2)
    }
    if !self.opType.isEmpty {
      try visitor.visitSingularStringField(value: self.opType, fieldNumber: 3)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularBytesField(value: self.message, fieldNumber: 4)
    }
    if self.errorCode != 0 {
      try visitor.visitSingularInt32Field(value: self.errorCode, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DexProtocol, rhs: DexProtocol) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.topics != rhs.topics {return false}
    if lhs.opType != rhs.opType {return false}
    if lhs.message != rhs.message {return false}
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TickerStatisticsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TickerStatisticsProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "symbol"),
    2: .same(proto: "tradeTokenSymbol"),
    3: .same(proto: "quoteTokenSymbol"),
    4: .same(proto: "tradeToken"),
    5: .same(proto: "quoteToken"),
    6: .same(proto: "openPrice"),
    7: .same(proto: "prevClosePrice"),
    8: .same(proto: "closePrice"),
    9: .same(proto: "priceChange"),
    10: .same(proto: "priceChangePercent"),
    11: .same(proto: "highPrice"),
    12: .same(proto: "lowPrice"),
    13: .same(proto: "quantity"),
    14: .same(proto: "amount"),
    15: .same(proto: "pricePrecision"),
    16: .same(proto: "quantityPrecision"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.symbol)
      case 2: try decoder.decodeSingularStringField(value: &self.tradeTokenSymbol)
      case 3: try decoder.decodeSingularStringField(value: &self.quoteTokenSymbol)
      case 4: try decoder.decodeSingularStringField(value: &self.tradeToken)
      case 5: try decoder.decodeSingularStringField(value: &self.quoteToken)
      case 6: try decoder.decodeSingularStringField(value: &self.openPrice)
      case 7: try decoder.decodeSingularStringField(value: &self.prevClosePrice)
      case 8: try decoder.decodeSingularStringField(value: &self.closePrice)
      case 9: try decoder.decodeSingularStringField(value: &self.priceChange)
      case 10: try decoder.decodeSingularStringField(value: &self.priceChangePercent)
      case 11: try decoder.decodeSingularStringField(value: &self.highPrice)
      case 12: try decoder.decodeSingularStringField(value: &self.lowPrice)
      case 13: try decoder.decodeSingularStringField(value: &self.quantity)
      case 14: try decoder.decodeSingularStringField(value: &self.amount)
      case 15: try decoder.decodeSingularInt32Field(value: &self.pricePrecision)
      case 16: try decoder.decodeSingularInt32Field(value: &self.quantityPrecision)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 1)
    }
    if !self.tradeTokenSymbol.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeTokenSymbol, fieldNumber: 2)
    }
    if !self.quoteTokenSymbol.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteTokenSymbol, fieldNumber: 3)
    }
    if !self.tradeToken.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeToken, fieldNumber: 4)
    }
    if !self.quoteToken.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteToken, fieldNumber: 5)
    }
    if !self.openPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.openPrice, fieldNumber: 6)
    }
    if !self.prevClosePrice.isEmpty {
      try visitor.visitSingularStringField(value: self.prevClosePrice, fieldNumber: 7)
    }
    if !self.closePrice.isEmpty {
      try visitor.visitSingularStringField(value: self.closePrice, fieldNumber: 8)
    }
    if !self.priceChange.isEmpty {
      try visitor.visitSingularStringField(value: self.priceChange, fieldNumber: 9)
    }
    if !self.priceChangePercent.isEmpty {
      try visitor.visitSingularStringField(value: self.priceChangePercent, fieldNumber: 10)
    }
    if !self.highPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.highPrice, fieldNumber: 11)
    }
    if !self.lowPrice.isEmpty {
      try visitor.visitSingularStringField(value: self.lowPrice, fieldNumber: 12)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 13)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 14)
    }
    if self.pricePrecision != 0 {
      try visitor.visitSingularInt32Field(value: self.pricePrecision, fieldNumber: 15)
    }
    if self.quantityPrecision != 0 {
      try visitor.visitSingularInt32Field(value: self.quantityPrecision, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TickerStatisticsProto, rhs: TickerStatisticsProto) -> Bool {
    if lhs.symbol != rhs.symbol {return false}
    if lhs.tradeTokenSymbol != rhs.tradeTokenSymbol {return false}
    if lhs.quoteTokenSymbol != rhs.quoteTokenSymbol {return false}
    if lhs.tradeToken != rhs.tradeToken {return false}
    if lhs.quoteToken != rhs.quoteToken {return false}
    if lhs.openPrice != rhs.openPrice {return false}
    if lhs.prevClosePrice != rhs.prevClosePrice {return false}
    if lhs.closePrice != rhs.closePrice {return false}
    if lhs.priceChange != rhs.priceChange {return false}
    if lhs.priceChangePercent != rhs.priceChangePercent {return false}
    if lhs.highPrice != rhs.highPrice {return false}
    if lhs.lowPrice != rhs.lowPrice {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.pricePrecision != rhs.pricePrecision {return false}
    if lhs.quantityPrecision != rhs.quantityPrecision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradeListProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TradeListProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trade"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.trade)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trade.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trade, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TradeListProto, rhs: TradeListProto) -> Bool {
    if lhs.trade != rhs.trade {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TradeProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TradeProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tradeId"),
    2: .same(proto: "symbol"),
    3: .same(proto: "tradeTokenSymbol"),
    4: .same(proto: "quoteTokenSymbol"),
    5: .same(proto: "tradeToken"),
    6: .same(proto: "quoteToken"),
    7: .same(proto: "price"),
    8: .same(proto: "quantity"),
    9: .same(proto: "amount"),
    10: .same(proto: "time"),
    11: .same(proto: "side"),
    12: .same(proto: "buyerOrderId"),
    13: .same(proto: "sellerOrderId"),
    14: .same(proto: "buyFee"),
    15: .same(proto: "sellFee"),
    16: .same(proto: "blockHeight"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.tradeID)
      case 2: try decoder.decodeSingularStringField(value: &self.symbol)
      case 3: try decoder.decodeSingularStringField(value: &self.tradeTokenSymbol)
      case 4: try decoder.decodeSingularStringField(value: &self.quoteTokenSymbol)
      case 5: try decoder.decodeSingularStringField(value: &self.tradeToken)
      case 6: try decoder.decodeSingularStringField(value: &self.quoteToken)
      case 7: try decoder.decodeSingularStringField(value: &self.price)
      case 8: try decoder.decodeSingularStringField(value: &self.quantity)
      case 9: try decoder.decodeSingularStringField(value: &self.amount)
      case 10: try decoder.decodeSingularInt64Field(value: &self.time)
      case 11: try decoder.decodeSingularInt32Field(value: &self.side)
      case 12: try decoder.decodeSingularStringField(value: &self.buyerOrderID)
      case 13: try decoder.decodeSingularStringField(value: &self.sellerOrderID)
      case 14: try decoder.decodeSingularStringField(value: &self.buyFee)
      case 15: try decoder.decodeSingularStringField(value: &self.sellFee)
      case 16: try decoder.decodeSingularInt64Field(value: &self.blockHeight)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tradeID.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeID, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if !self.tradeTokenSymbol.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeTokenSymbol, fieldNumber: 3)
    }
    if !self.quoteTokenSymbol.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteTokenSymbol, fieldNumber: 4)
    }
    if !self.tradeToken.isEmpty {
      try visitor.visitSingularStringField(value: self.tradeToken, fieldNumber: 5)
    }
    if !self.quoteToken.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteToken, fieldNumber: 6)
    }
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 7)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 8)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 9)
    }
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 10)
    }
    if self.side != 0 {
      try visitor.visitSingularInt32Field(value: self.side, fieldNumber: 11)
    }
    if !self.buyerOrderID.isEmpty {
      try visitor.visitSingularStringField(value: self.buyerOrderID, fieldNumber: 12)
    }
    if !self.sellerOrderID.isEmpty {
      try visitor.visitSingularStringField(value: self.sellerOrderID, fieldNumber: 13)
    }
    if !self.buyFee.isEmpty {
      try visitor.visitSingularStringField(value: self.buyFee, fieldNumber: 14)
    }
    if !self.sellFee.isEmpty {
      try visitor.visitSingularStringField(value: self.sellFee, fieldNumber: 15)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.blockHeight, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TradeProto, rhs: TradeProto) -> Bool {
    if lhs.tradeID != rhs.tradeID {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.tradeTokenSymbol != rhs.tradeTokenSymbol {return false}
    if lhs.quoteTokenSymbol != rhs.quoteTokenSymbol {return false}
    if lhs.tradeToken != rhs.tradeToken {return false}
    if lhs.quoteToken != rhs.quoteToken {return false}
    if lhs.price != rhs.price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.time != rhs.time {return false}
    if lhs.side != rhs.side {return false}
    if lhs.buyerOrderID != rhs.buyerOrderID {return false}
    if lhs.sellerOrderID != rhs.sellerOrderID {return false}
    if lhs.buyFee != rhs.buyFee {return false}
    if lhs.sellFee != rhs.sellFee {return false}
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KlineProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "KlineProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "t"),
    2: .same(proto: "c"),
    3: .same(proto: "o"),
    4: .same(proto: "h"),
    5: .same(proto: "l"),
    6: .same(proto: "v"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.t)
      case 2: try decoder.decodeSingularDoubleField(value: &self.c)
      case 3: try decoder.decodeSingularDoubleField(value: &self.o)
      case 4: try decoder.decodeSingularDoubleField(value: &self.h)
      case 5: try decoder.decodeSingularDoubleField(value: &self.l)
      case 6: try decoder.decodeSingularDoubleField(value: &self.v)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.t != 0 {
      try visitor.visitSingularInt64Field(value: self.t, fieldNumber: 1)
    }
    if self.c != 0 {
      try visitor.visitSingularDoubleField(value: self.c, fieldNumber: 2)
    }
    if self.o != 0 {
      try visitor.visitSingularDoubleField(value: self.o, fieldNumber: 3)
    }
    if self.h != 0 {
      try visitor.visitSingularDoubleField(value: self.h, fieldNumber: 4)
    }
    if self.l != 0 {
      try visitor.visitSingularDoubleField(value: self.l, fieldNumber: 5)
    }
    if self.v != 0 {
      try visitor.visitSingularDoubleField(value: self.v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KlineProto, rhs: KlineProto) -> Bool {
    if lhs.t != rhs.t {return false}
    if lhs.c != rhs.c {return false}
    if lhs.o != rhs.o {return false}
    if lhs.h != rhs.h {return false}
    if lhs.l != rhs.l {return false}
    if lhs.v != rhs.v {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "OrderProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orderId"),
    2: .same(proto: "symbol"),
    3: .same(proto: "tradeTokenSymbol"),
    4: .same(proto: "quoteTokenSymbol"),
    5: .same(proto: "tradeToken"),
    6: .same(proto: "quoteToken"),
    7: .same(proto: "side"),
    8: .same(proto: "price"),
    9: .same(proto: "quantity"),
    10: .same(proto: "amount"),
    11: .same(proto: "executedQuantity"),
    12: .same(proto: "executedAmount"),
    13: .same(proto: "executedPercent"),
    14: .same(proto: "executedAvgPrice"),
    15: .same(proto: "fee"),
    16: .same(proto: "status"),
    17: .same(proto: "type"),
    18: .same(proto: "createTime"),
    19: .same(proto: "address"),
    20: .same(proto: "orderHash"),
  ]

  fileprivate class _StorageClass {
    var _orderID: String = String()
    var _symbol: String = String()
    var _tradeTokenSymbol: String = String()
    var _quoteTokenSymbol: String = String()
    var _tradeToken: String = String()
    var _quoteToken: String = String()
    var _side: Int32 = 0
    var _price: String = String()
    var _quantity: String = String()
    var _amount: String = String()
    var _executedQuantity: String = String()
    var _executedAmount: String = String()
    var _executedPercent: String = String()
    var _executedAvgPrice: String = String()
    var _fee: String = String()
    var _status: Int32 = 0
    var _type: Int32 = 0
    var _createTime: Int64 = 0
    var _address: String = String()
    var _orderHash: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _orderID = source._orderID
      _symbol = source._symbol
      _tradeTokenSymbol = source._tradeTokenSymbol
      _quoteTokenSymbol = source._quoteTokenSymbol
      _tradeToken = source._tradeToken
      _quoteToken = source._quoteToken
      _side = source._side
      _price = source._price
      _quantity = source._quantity
      _amount = source._amount
      _executedQuantity = source._executedQuantity
      _executedAmount = source._executedAmount
      _executedPercent = source._executedPercent
      _executedAvgPrice = source._executedAvgPrice
      _fee = source._fee
      _status = source._status
      _type = source._type
      _createTime = source._createTime
      _address = source._address
      _orderHash = source._orderHash
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._orderID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._symbol)
        case 3: try decoder.decodeSingularStringField(value: &_storage._tradeTokenSymbol)
        case 4: try decoder.decodeSingularStringField(value: &_storage._quoteTokenSymbol)
        case 5: try decoder.decodeSingularStringField(value: &_storage._tradeToken)
        case 6: try decoder.decodeSingularStringField(value: &_storage._quoteToken)
        case 7: try decoder.decodeSingularInt32Field(value: &_storage._side)
        case 8: try decoder.decodeSingularStringField(value: &_storage._price)
        case 9: try decoder.decodeSingularStringField(value: &_storage._quantity)
        case 10: try decoder.decodeSingularStringField(value: &_storage._amount)
        case 11: try decoder.decodeSingularStringField(value: &_storage._executedQuantity)
        case 12: try decoder.decodeSingularStringField(value: &_storage._executedAmount)
        case 13: try decoder.decodeSingularStringField(value: &_storage._executedPercent)
        case 14: try decoder.decodeSingularStringField(value: &_storage._executedAvgPrice)
        case 15: try decoder.decodeSingularStringField(value: &_storage._fee)
        case 16: try decoder.decodeSingularInt32Field(value: &_storage._status)
        case 17: try decoder.decodeSingularInt32Field(value: &_storage._type)
        case 18: try decoder.decodeSingularInt64Field(value: &_storage._createTime)
        case 19: try decoder.decodeSingularStringField(value: &_storage._address)
        case 20: try decoder.decodeSingularStringField(value: &_storage._orderHash)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._orderID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._orderID, fieldNumber: 1)
      }
      if !_storage._symbol.isEmpty {
        try visitor.visitSingularStringField(value: _storage._symbol, fieldNumber: 2)
      }
      if !_storage._tradeTokenSymbol.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tradeTokenSymbol, fieldNumber: 3)
      }
      if !_storage._quoteTokenSymbol.isEmpty {
        try visitor.visitSingularStringField(value: _storage._quoteTokenSymbol, fieldNumber: 4)
      }
      if !_storage._tradeToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tradeToken, fieldNumber: 5)
      }
      if !_storage._quoteToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._quoteToken, fieldNumber: 6)
      }
      if _storage._side != 0 {
        try visitor.visitSingularInt32Field(value: _storage._side, fieldNumber: 7)
      }
      if !_storage._price.isEmpty {
        try visitor.visitSingularStringField(value: _storage._price, fieldNumber: 8)
      }
      if !_storage._quantity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._quantity, fieldNumber: 9)
      }
      if !_storage._amount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._amount, fieldNumber: 10)
      }
      if !_storage._executedQuantity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._executedQuantity, fieldNumber: 11)
      }
      if !_storage._executedAmount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._executedAmount, fieldNumber: 12)
      }
      if !_storage._executedPercent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._executedPercent, fieldNumber: 13)
      }
      if !_storage._executedAvgPrice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._executedAvgPrice, fieldNumber: 14)
      }
      if !_storage._fee.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fee, fieldNumber: 15)
      }
      if _storage._status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._status, fieldNumber: 16)
      }
      if _storage._type != 0 {
        try visitor.visitSingularInt32Field(value: _storage._type, fieldNumber: 17)
      }
      if _storage._createTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createTime, fieldNumber: 18)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 19)
      }
      if !_storage._orderHash.isEmpty {
        try visitor.visitSingularStringField(value: _storage._orderHash, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OrderProto, rhs: OrderProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._orderID != rhs_storage._orderID {return false}
        if _storage._symbol != rhs_storage._symbol {return false}
        if _storage._tradeTokenSymbol != rhs_storage._tradeTokenSymbol {return false}
        if _storage._quoteTokenSymbol != rhs_storage._quoteTokenSymbol {return false}
        if _storage._tradeToken != rhs_storage._tradeToken {return false}
        if _storage._quoteToken != rhs_storage._quoteToken {return false}
        if _storage._side != rhs_storage._side {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._executedQuantity != rhs_storage._executedQuantity {return false}
        if _storage._executedAmount != rhs_storage._executedAmount {return false}
        if _storage._executedPercent != rhs_storage._executedPercent {return false}
        if _storage._executedAvgPrice != rhs_storage._executedAvgPrice {return false}
        if _storage._fee != rhs_storage._fee {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._orderHash != rhs_storage._orderHash {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DepthListProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DepthListProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "asks"),
    2: .same(proto: "bids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.asks)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.bids)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.asks, fieldNumber: 1)
    }
    if !self.bids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DepthListProto, rhs: DepthListProto) -> Bool {
    if lhs.asks != rhs.asks {return false}
    if lhs.bids != rhs.bids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DepthProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DepthProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .same(proto: "quantity"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.price)
      case 2: try decoder.decodeSingularStringField(value: &self.quantity)
      case 3: try decoder.decodeSingularStringField(value: &self.amount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.price.isEmpty {
      try visitor.visitSingularStringField(value: self.price, fieldNumber: 1)
    }
    if !self.quantity.isEmpty {
      try visitor.visitSingularStringField(value: self.quantity, fieldNumber: 2)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DepthProto, rhs: DepthProto) -> Bool {
    if lhs.price != rhs.price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
