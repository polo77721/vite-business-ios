/// Generated by the Protocol Buffers 3.7.1 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 4.0.0
/// Source file "market.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Protocol { }

public extension Protocol {
    public struct MarketRoot {
        public static let `default` = MarketRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class DexProtocol : GeneratedMessage {
        public typealias BuilderType = Protocol.DexProtocol.Builder

        public static func == (lhs: Protocol.DexProtocol, rhs: Protocol.DexProtocol) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasClientId == rhs.hasClientId) && (!lhs.hasClientId || lhs.clientId == rhs.clientId)
            fieldCheck = fieldCheck && (lhs.hasTopics == rhs.hasTopics) && (!lhs.hasTopics || lhs.topics == rhs.topics)
            fieldCheck = fieldCheck && (lhs.hasOpType == rhs.hasOpType) && (!lhs.hasOpType || lhs.opType == rhs.opType)
            fieldCheck = fieldCheck && (lhs.hasMessage == rhs.hasMessage) && (!lhs.hasMessage || lhs.message == rhs.message)
            fieldCheck = fieldCheck && (lhs.hasErrorCode == rhs.hasErrorCode) && (!lhs.hasErrorCode || lhs.errorCode == rhs.errorCode)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///Identify a single client
        public fileprivate(set) var clientId:String! = nil
        public fileprivate(set) var hasClientId:Bool = false

        ///见下面
        public fileprivate(set) var topics:String! = nil
        public fileprivate(set) var hasTopics:Bool = false

        /// sub,un_sub,ping,pong,push
        public fileprivate(set) var opType:String! = nil
        public fileprivate(set) var hasOpType:Bool = false

        ///proto数据
        public fileprivate(set) var message:Data! = nil
        public fileprivate(set) var hasMessage:Bool = false

        ///错误编码 0:normal, 1:illegal_client_id，2:illegal_topics，3:illegal_op_type,5:visit_limit
        public fileprivate(set) var errorCode:Int32! = nil
        public fileprivate(set) var hasErrorCode:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasClientId {
                try codedOutputStream.writeString(fieldNumber: 1, value:clientId)
            }
            if hasTopics {
                try codedOutputStream.writeString(fieldNumber: 2, value:topics)
            }
            if hasOpType {
                try codedOutputStream.writeString(fieldNumber: 3, value:opType)
            }
            if hasMessage {
                try codedOutputStream.writeData(fieldNumber: 4, value:message)
            }
            if hasErrorCode {
                try codedOutputStream.writeInt32(fieldNumber: 5, value:errorCode)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasClientId {
                serialize_size += clientId.computeStringSize(fieldNumber: 1)
            }
            if hasTopics {
                serialize_size += topics.computeStringSize(fieldNumber: 2)
            }
            if hasOpType {
                serialize_size += opType.computeStringSize(fieldNumber: 3)
            }
            if hasMessage {
                serialize_size += message.computeDataSize(fieldNumber: 4)
            }
            if hasErrorCode {
                serialize_size += errorCode.computeInt32Size(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Protocol.DexProtocol.Builder {
            return Protocol.DexProtocol.classBuilder() as! Protocol.DexProtocol.Builder
        }
        public func getBuilder() -> Protocol.DexProtocol.Builder {
            return classBuilder() as! Protocol.DexProtocol.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Protocol.DexProtocol.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Protocol.DexProtocol.Builder()
        }
        public func toBuilder() throws -> Protocol.DexProtocol.Builder {
            return try Protocol.DexProtocol.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Protocol.DexProtocol) throws -> Protocol.DexProtocol.Builder {
            return try Protocol.DexProtocol.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasClientId {
                jsonMap["clientId"] = clientId
            }
            if hasTopics {
                jsonMap["topics"] = topics
            }
            if hasOpType {
                jsonMap["opType"] = opType
            }
            if hasMessage {
                jsonMap["message"] = message.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasErrorCode {
                jsonMap["errorCode"] = Int(errorCode)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Protocol.DexProtocol {
            return try Protocol.DexProtocol.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Protocol.DexProtocol {
            return try Protocol.DexProtocol.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasClientId {
                output += "\(indent) clientId: \(String(describing: clientId)) \n"
            }
            if hasTopics {
                output += "\(indent) topics: \(String(describing: topics)) \n"
            }
            if hasOpType {
                output += "\(indent) opType: \(String(describing: opType)) \n"
            }
            if hasMessage {
                output += "\(indent) message: \(String(describing: message)) \n"
            }
            if hasErrorCode {
                output += "\(indent) errorCode: \(String(describing: errorCode)) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasClientId {
                    hashCode = (hashCode &* 31) &+ clientId.hashValue
                }
                if hasTopics {
                    hashCode = (hashCode &* 31) &+ topics.hashValue
                }
                if hasOpType {
                    hashCode = (hashCode &* 31) &+ opType.hashValue
                }
                if hasMessage {
                    hashCode = (hashCode &* 31) &+ message.hashValue
                }
                if hasErrorCode {
                    hashCode = (hashCode &* 31) &+ errorCode.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Protocol.DexProtocol"
        }
        override public func className() -> String {
            return "Protocol.DexProtocol"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Protocol.DexProtocol = Protocol.DexProtocol()
            public func getMessage() -> Protocol.DexProtocol {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///Identify a single client
            public var clientId:String {
                get {
                    return builderResult.clientId
                }
                set (value) {
                    builderResult.hasClientId = true
                    builderResult.clientId = value
                }
            }
            public var hasClientId:Bool {
                get {
                    return builderResult.hasClientId
                }
            }
            @discardableResult
            public func setClientId(_ value:String) -> Protocol.DexProtocol.Builder {
                self.clientId = value
                return self
            }
            @discardableResult
            public func clearClientId() -> Protocol.DexProtocol.Builder{
                builderResult.hasClientId = false
                builderResult.clientId = nil
                return self
            }
            ///见下面
            public var topics:String {
                get {
                    return builderResult.topics
                }
                set (value) {
                    builderResult.hasTopics = true
                    builderResult.topics = value
                }
            }
            public var hasTopics:Bool {
                get {
                    return builderResult.hasTopics
                }
            }
            @discardableResult
            public func setTopics(_ value:String) -> Protocol.DexProtocol.Builder {
                self.topics = value
                return self
            }
            @discardableResult
            public func clearTopics() -> Protocol.DexProtocol.Builder{
                builderResult.hasTopics = false
                builderResult.topics = nil
                return self
            }
            /// sub,un_sub,ping,pong,push
            public var opType:String {
                get {
                    return builderResult.opType
                }
                set (value) {
                    builderResult.hasOpType = true
                    builderResult.opType = value
                }
            }
            public var hasOpType:Bool {
                get {
                    return builderResult.hasOpType
                }
            }
            @discardableResult
            public func setOpType(_ value:String) -> Protocol.DexProtocol.Builder {
                self.opType = value
                return self
            }
            @discardableResult
            public func clearOpType() -> Protocol.DexProtocol.Builder{
                builderResult.hasOpType = false
                builderResult.opType = nil
                return self
            }
            ///proto数据
            public var message:Data {
                get {
                    return builderResult.message
                }
                set (value) {
                    builderResult.hasMessage = true
                    builderResult.message = value
                }
            }
            public var hasMessage:Bool {
                get {
                    return builderResult.hasMessage
                }
            }
            @discardableResult
            public func setMessage(_ value:Data) -> Protocol.DexProtocol.Builder {
                self.message = value
                return self
            }
            @discardableResult
            public func clearMessage() -> Protocol.DexProtocol.Builder{
                builderResult.hasMessage = false
                builderResult.message = nil
                return self
            }
            ///错误编码 0:normal, 1:illegal_client_id，2:illegal_topics，3:illegal_op_type,5:visit_limit
            public var errorCode:Int32 {
                get {
                    return builderResult.errorCode
                }
                set (value) {
                    builderResult.hasErrorCode = true
                    builderResult.errorCode = value
                }
            }
            public var hasErrorCode:Bool {
                get {
                    return builderResult.hasErrorCode
                }
            }
            @discardableResult
            public func setErrorCode(_ value:Int32) -> Protocol.DexProtocol.Builder {
                self.errorCode = value
                return self
            }
            @discardableResult
            public func clearErrorCode() -> Protocol.DexProtocol.Builder{
                builderResult.hasErrorCode = false
                builderResult.errorCode = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Protocol.DexProtocol.Builder {
                builderResult = Protocol.DexProtocol()
                return self
            }
            override public func clone() throws -> Protocol.DexProtocol.Builder {
                return try Protocol.DexProtocol.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Protocol.DexProtocol {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Protocol.DexProtocol {
                let returnMe:Protocol.DexProtocol = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Protocol.DexProtocol) throws -> Protocol.DexProtocol.Builder {
                if other == Protocol.DexProtocol() {
                    return self
                }
                if other.hasClientId {
                    clientId = other.clientId
                }
                if other.hasTopics {
                    topics = other.topics
                }
                if other.hasOpType {
                    opType = other.opType
                }
                if other.hasMessage {
                    message = other.message
                }
                if other.hasErrorCode {
                    errorCode = other.errorCode
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Protocol.DexProtocol.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.DexProtocol.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        clientId = try codedInputStream.readString()

                    case 18:
                        topics = try codedInputStream.readString()

                    case 26:
                        opType = try codedInputStream.readString()

                    case 34:
                        message = try codedInputStream.readData()

                    case 40:
                        errorCode = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Protocol.DexProtocol.Builder {
                let resultDecodedBuilder = Protocol.DexProtocol.Builder()
                if let jsonValueClientId = jsonMap["clientId"] as? String {
                    resultDecodedBuilder.clientId = jsonValueClientId
                }
                if let jsonValueTopics = jsonMap["topics"] as? String {
                    resultDecodedBuilder.topics = jsonValueTopics
                }
                if let jsonValueOpType = jsonMap["opType"] as? String {
                    resultDecodedBuilder.opType = jsonValueOpType
                }
                if let jsonValueMessage = jsonMap["message"] as? String {
                    resultDecodedBuilder.message = Data(base64Encoded:jsonValueMessage, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueErrorCode = jsonMap["errorCode"] as? Int {
                    resultDecodedBuilder.errorCode = Int32(jsonValueErrorCode)
                } else if let jsonValueErrorCode = jsonMap["errorCode"] as? String {
                    resultDecodedBuilder.errorCode = Int32(jsonValueErrorCode)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Protocol.DexProtocol.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Protocol.DexProtocol.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TickerStatisticsProto : GeneratedMessage {
        public typealias BuilderType = Protocol.TickerStatisticsProto.Builder

        public static func == (lhs: Protocol.TickerStatisticsProto, rhs: Protocol.TickerStatisticsProto) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSymbol == rhs.hasSymbol) && (!lhs.hasSymbol || lhs.symbol == rhs.symbol)
            fieldCheck = fieldCheck && (lhs.hasTradeTokenSymbol == rhs.hasTradeTokenSymbol) && (!lhs.hasTradeTokenSymbol || lhs.tradeTokenSymbol == rhs.tradeTokenSymbol)
            fieldCheck = fieldCheck && (lhs.hasQuoteTokenSymbol == rhs.hasQuoteTokenSymbol) && (!lhs.hasQuoteTokenSymbol || lhs.quoteTokenSymbol == rhs.quoteTokenSymbol)
            fieldCheck = fieldCheck && (lhs.hasTradeToken == rhs.hasTradeToken) && (!lhs.hasTradeToken || lhs.tradeToken == rhs.tradeToken)
            fieldCheck = fieldCheck && (lhs.hasQuoteToken == rhs.hasQuoteToken) && (!lhs.hasQuoteToken || lhs.quoteToken == rhs.quoteToken)
            fieldCheck = fieldCheck && (lhs.hasOpenPrice == rhs.hasOpenPrice) && (!lhs.hasOpenPrice || lhs.openPrice == rhs.openPrice)
            fieldCheck = fieldCheck && (lhs.hasPrevClosePrice == rhs.hasPrevClosePrice) && (!lhs.hasPrevClosePrice || lhs.prevClosePrice == rhs.prevClosePrice)
            fieldCheck = fieldCheck && (lhs.hasClosePrice == rhs.hasClosePrice) && (!lhs.hasClosePrice || lhs.closePrice == rhs.closePrice)
            fieldCheck = fieldCheck && (lhs.hasPriceChange == rhs.hasPriceChange) && (!lhs.hasPriceChange || lhs.priceChange == rhs.priceChange)
            fieldCheck = fieldCheck && (lhs.hasPriceChangePercent == rhs.hasPriceChangePercent) && (!lhs.hasPriceChangePercent || lhs.priceChangePercent == rhs.priceChangePercent)
            fieldCheck = fieldCheck && (lhs.hasHighPrice == rhs.hasHighPrice) && (!lhs.hasHighPrice || lhs.highPrice == rhs.highPrice)
            fieldCheck = fieldCheck && (lhs.hasLowPrice == rhs.hasLowPrice) && (!lhs.hasLowPrice || lhs.lowPrice == rhs.lowPrice)
            fieldCheck = fieldCheck && (lhs.hasQuantity == rhs.hasQuantity) && (!lhs.hasQuantity || lhs.quantity == rhs.quantity)
            fieldCheck = fieldCheck && (lhs.hasAmount == rhs.hasAmount) && (!lhs.hasAmount || lhs.amount == rhs.amount)
            fieldCheck = fieldCheck && (lhs.hasPricePrecision == rhs.hasPricePrecision) && (!lhs.hasPricePrecision || lhs.pricePrecision == rhs.pricePrecision)
            fieldCheck = fieldCheck && (lhs.hasQuantityPrecision == rhs.hasQuantityPrecision) && (!lhs.hasQuantityPrecision || lhs.quantityPrecision == rhs.quantityPrecision)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///symbol
        public fileprivate(set) var symbol:String! = nil
        public fileprivate(set) var hasSymbol:Bool = false

        ///symbol
        public fileprivate(set) var tradeTokenSymbol:String! = nil
        public fileprivate(set) var hasTradeTokenSymbol:Bool = false

        ///symbol
        public fileprivate(set) var quoteTokenSymbol:String! = nil
        public fileprivate(set) var hasQuoteTokenSymbol:Bool = false

        ///tokenId
        public fileprivate(set) var tradeToken:String! = nil
        public fileprivate(set) var hasTradeToken:Bool = false

        ///tokenId
        public fileprivate(set) var quoteToken:String! = nil
        public fileprivate(set) var hasQuoteToken:Bool = false

        ///价格
        public fileprivate(set) var openPrice:String! = nil
        public fileprivate(set) var hasOpenPrice:Bool = false

        ///价格
        public fileprivate(set) var prevClosePrice:String! = nil
        public fileprivate(set) var hasPrevClosePrice:Bool = false

        ///价格
        public fileprivate(set) var closePrice:String! = nil
        public fileprivate(set) var hasClosePrice:Bool = false

        ///价格
        public fileprivate(set) var priceChange:String! = nil
        public fileprivate(set) var hasPriceChange:Bool = false

        ///变化率
        public fileprivate(set) var priceChangePercent:Double! = nil
        public fileprivate(set) var hasPriceChangePercent:Bool = false

        ///价格
        public fileprivate(set) var highPrice:String! = nil
        public fileprivate(set) var hasHighPrice:Bool = false

        ///价格
        public fileprivate(set) var lowPrice:String! = nil
        public fileprivate(set) var hasLowPrice:Bool = false

        ///数量
        public fileprivate(set) var quantity:String! = nil
        public fileprivate(set) var hasQuantity:Bool = false

        ///成交额
        public fileprivate(set) var amount:String! = nil
        public fileprivate(set) var hasAmount:Bool = false

        ///price精度
        public fileprivate(set) var pricePrecision:Int32! = nil
        public fileprivate(set) var hasPricePrecision:Bool = false

        ///quantity精度
        public fileprivate(set) var quantityPrecision:Int32! = nil
        public fileprivate(set) var hasQuantityPrecision:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSymbol {
                try codedOutputStream.writeString(fieldNumber: 1, value:symbol)
            }
            if hasTradeTokenSymbol {
                try codedOutputStream.writeString(fieldNumber: 2, value:tradeTokenSymbol)
            }
            if hasQuoteTokenSymbol {
                try codedOutputStream.writeString(fieldNumber: 3, value:quoteTokenSymbol)
            }
            if hasTradeToken {
                try codedOutputStream.writeString(fieldNumber: 4, value:tradeToken)
            }
            if hasQuoteToken {
                try codedOutputStream.writeString(fieldNumber: 5, value:quoteToken)
            }
            if hasOpenPrice {
                try codedOutputStream.writeString(fieldNumber: 6, value:openPrice)
            }
            if hasPrevClosePrice {
                try codedOutputStream.writeString(fieldNumber: 7, value:prevClosePrice)
            }
            if hasClosePrice {
                try codedOutputStream.writeString(fieldNumber: 8, value:closePrice)
            }
            if hasPriceChange {
                try codedOutputStream.writeString(fieldNumber: 9, value:priceChange)
            }
            if hasPriceChangePercent {
                try codedOutputStream.writeDouble(fieldNumber: 10, value: priceChangePercent)
            }
            if hasHighPrice {
                try codedOutputStream.writeString(fieldNumber: 11, value:highPrice)
            }
            if hasLowPrice {
                try codedOutputStream.writeString(fieldNumber: 12, value:lowPrice)
            }
            if hasQuantity {
                try codedOutputStream.writeString(fieldNumber: 13, value:quantity)
            }
            if hasAmount {
                try codedOutputStream.writeString(fieldNumber: 14, value:amount)
            }
            if hasPricePrecision {
                try codedOutputStream.writeInt32(fieldNumber: 15, value:pricePrecision)
            }
            if hasQuantityPrecision {
                try codedOutputStream.writeInt32(fieldNumber: 16, value:quantityPrecision)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSymbol {
                serialize_size += symbol.computeStringSize(fieldNumber: 1)
            }
            if hasTradeTokenSymbol {
                serialize_size += tradeTokenSymbol.computeStringSize(fieldNumber: 2)
            }
            if hasQuoteTokenSymbol {
                serialize_size += quoteTokenSymbol.computeStringSize(fieldNumber: 3)
            }
            if hasTradeToken {
                serialize_size += tradeToken.computeStringSize(fieldNumber: 4)
            }
            if hasQuoteToken {
                serialize_size += quoteToken.computeStringSize(fieldNumber: 5)
            }
            if hasOpenPrice {
                serialize_size += openPrice.computeStringSize(fieldNumber: 6)
            }
            if hasPrevClosePrice {
                serialize_size += prevClosePrice.computeStringSize(fieldNumber: 7)
            }
            if hasClosePrice {
                serialize_size += closePrice.computeStringSize(fieldNumber: 8)
            }
            if hasPriceChange {
                serialize_size += priceChange.computeStringSize(fieldNumber: 9)
            }
            if hasPriceChangePercent {
                serialize_size += priceChangePercent.computeDoubleSize(fieldNumber: 10)
            }
            if hasHighPrice {
                serialize_size += highPrice.computeStringSize(fieldNumber: 11)
            }
            if hasLowPrice {
                serialize_size += lowPrice.computeStringSize(fieldNumber: 12)
            }
            if hasQuantity {
                serialize_size += quantity.computeStringSize(fieldNumber: 13)
            }
            if hasAmount {
                serialize_size += amount.computeStringSize(fieldNumber: 14)
            }
            if hasPricePrecision {
                serialize_size += pricePrecision.computeInt32Size(fieldNumber: 15)
            }
            if hasQuantityPrecision {
                serialize_size += quantityPrecision.computeInt32Size(fieldNumber: 16)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Protocol.TickerStatisticsProto.Builder {
            return Protocol.TickerStatisticsProto.classBuilder() as! Protocol.TickerStatisticsProto.Builder
        }
        public func getBuilder() -> Protocol.TickerStatisticsProto.Builder {
            return classBuilder() as! Protocol.TickerStatisticsProto.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Protocol.TickerStatisticsProto.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Protocol.TickerStatisticsProto.Builder()
        }
        public func toBuilder() throws -> Protocol.TickerStatisticsProto.Builder {
            return try Protocol.TickerStatisticsProto.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Protocol.TickerStatisticsProto) throws -> Protocol.TickerStatisticsProto.Builder {
            return try Protocol.TickerStatisticsProto.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSymbol {
                jsonMap["symbol"] = symbol
            }
            if hasTradeTokenSymbol {
                jsonMap["tradeTokenSymbol"] = tradeTokenSymbol
            }
            if hasQuoteTokenSymbol {
                jsonMap["quoteTokenSymbol"] = quoteTokenSymbol
            }
            if hasTradeToken {
                jsonMap["tradeToken"] = tradeToken
            }
            if hasQuoteToken {
                jsonMap["quoteToken"] = quoteToken
            }
            if hasOpenPrice {
                jsonMap["openPrice"] = openPrice
            }
            if hasPrevClosePrice {
                jsonMap["prevClosePrice"] = prevClosePrice
            }
            if hasClosePrice {
                jsonMap["closePrice"] = closePrice
            }
            if hasPriceChange {
                jsonMap["priceChange"] = priceChange
            }
            if hasPriceChangePercent {
                jsonMap["priceChangePercent"] = priceChangePercent
            }
            if hasHighPrice {
                jsonMap["highPrice"] = highPrice
            }
            if hasLowPrice {
                jsonMap["lowPrice"] = lowPrice
            }
            if hasQuantity {
                jsonMap["quantity"] = quantity
            }
            if hasAmount {
                jsonMap["amount"] = amount
            }
            if hasPricePrecision {
                jsonMap["pricePrecision"] = Int(pricePrecision)
            }
            if hasQuantityPrecision {
                jsonMap["quantityPrecision"] = Int(quantityPrecision)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Protocol.TickerStatisticsProto {
            return try Protocol.TickerStatisticsProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Protocol.TickerStatisticsProto {
            return try Protocol.TickerStatisticsProto.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSymbol {
                output += "\(indent) symbol: \(String(describing: symbol)) \n"
            }
            if hasTradeTokenSymbol {
                output += "\(indent) tradeTokenSymbol: \(String(describing: tradeTokenSymbol)) \n"
            }
            if hasQuoteTokenSymbol {
                output += "\(indent) quoteTokenSymbol: \(String(describing: quoteTokenSymbol)) \n"
            }
            if hasTradeToken {
                output += "\(indent) tradeToken: \(String(describing: tradeToken)) \n"
            }
            if hasQuoteToken {
                output += "\(indent) quoteToken: \(String(describing: quoteToken)) \n"
            }
            if hasOpenPrice {
                output += "\(indent) openPrice: \(String(describing: openPrice)) \n"
            }
            if hasPrevClosePrice {
                output += "\(indent) prevClosePrice: \(String(describing: prevClosePrice)) \n"
            }
            if hasClosePrice {
                output += "\(indent) closePrice: \(String(describing: closePrice)) \n"
            }
            if hasPriceChange {
                output += "\(indent) priceChange: \(String(describing: priceChange)) \n"
            }
            if hasPriceChangePercent {
                output += "\(indent) priceChangePercent: \(String(describing: priceChangePercent)) \n"
            }
            if hasHighPrice {
                output += "\(indent) highPrice: \(String(describing: highPrice)) \n"
            }
            if hasLowPrice {
                output += "\(indent) lowPrice: \(String(describing: lowPrice)) \n"
            }
            if hasQuantity {
                output += "\(indent) quantity: \(String(describing: quantity)) \n"
            }
            if hasAmount {
                output += "\(indent) amount: \(String(describing: amount)) \n"
            }
            if hasPricePrecision {
                output += "\(indent) pricePrecision: \(String(describing: pricePrecision)) \n"
            }
            if hasQuantityPrecision {
                output += "\(indent) quantityPrecision: \(String(describing: quantityPrecision)) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSymbol {
                    hashCode = (hashCode &* 31) &+ symbol.hashValue
                }
                if hasTradeTokenSymbol {
                    hashCode = (hashCode &* 31) &+ tradeTokenSymbol.hashValue
                }
                if hasQuoteTokenSymbol {
                    hashCode = (hashCode &* 31) &+ quoteTokenSymbol.hashValue
                }
                if hasTradeToken {
                    hashCode = (hashCode &* 31) &+ tradeToken.hashValue
                }
                if hasQuoteToken {
                    hashCode = (hashCode &* 31) &+ quoteToken.hashValue
                }
                if hasOpenPrice {
                    hashCode = (hashCode &* 31) &+ openPrice.hashValue
                }
                if hasPrevClosePrice {
                    hashCode = (hashCode &* 31) &+ prevClosePrice.hashValue
                }
                if hasClosePrice {
                    hashCode = (hashCode &* 31) &+ closePrice.hashValue
                }
                if hasPriceChange {
                    hashCode = (hashCode &* 31) &+ priceChange.hashValue
                }
                if hasPriceChangePercent {
                    hashCode = (hashCode &* 31) &+ priceChangePercent.hashValue
                }
                if hasHighPrice {
                    hashCode = (hashCode &* 31) &+ highPrice.hashValue
                }
                if hasLowPrice {
                    hashCode = (hashCode &* 31) &+ lowPrice.hashValue
                }
                if hasQuantity {
                    hashCode = (hashCode &* 31) &+ quantity.hashValue
                }
                if hasAmount {
                    hashCode = (hashCode &* 31) &+ amount.hashValue
                }
                if hasPricePrecision {
                    hashCode = (hashCode &* 31) &+ pricePrecision.hashValue
                }
                if hasQuantityPrecision {
                    hashCode = (hashCode &* 31) &+ quantityPrecision.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Protocol.TickerStatisticsProto"
        }
        override public func className() -> String {
            return "Protocol.TickerStatisticsProto"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Protocol.TickerStatisticsProto = Protocol.TickerStatisticsProto()
            public func getMessage() -> Protocol.TickerStatisticsProto {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///symbol
            public var symbol:String {
                get {
                    return builderResult.symbol
                }
                set (value) {
                    builderResult.hasSymbol = true
                    builderResult.symbol = value
                }
            }
            public var hasSymbol:Bool {
                get {
                    return builderResult.hasSymbol
                }
            }
            @discardableResult
            public func setSymbol(_ value:String) -> Protocol.TickerStatisticsProto.Builder {
                self.symbol = value
                return self
            }
            @discardableResult
            public func clearSymbol() -> Protocol.TickerStatisticsProto.Builder{
                builderResult.hasSymbol = false
                builderResult.symbol = nil
                return self
            }
            ///symbol
            public var tradeTokenSymbol:String {
                get {
                    return builderResult.tradeTokenSymbol
                }
                set (value) {
                    builderResult.hasTradeTokenSymbol = true
                    builderResult.tradeTokenSymbol = value
                }
            }
            public var hasTradeTokenSymbol:Bool {
                get {
                    return builderResult.hasTradeTokenSymbol
                }
            }
            @discardableResult
            public func setTradeTokenSymbol(_ value:String) -> Protocol.TickerStatisticsProto.Builder {
                self.tradeTokenSymbol = value
                return self
            }
            @discardableResult
            public func clearTradeTokenSymbol() -> Protocol.TickerStatisticsProto.Builder{
                builderResult.hasTradeTokenSymbol = false
                builderResult.tradeTokenSymbol = nil
                return self
            }
            ///symbol
            public var quoteTokenSymbol:String {
                get {
                    return builderResult.quoteTokenSymbol
                }
                set (value) {
                    builderResult.hasQuoteTokenSymbol = true
                    builderResult.quoteTokenSymbol = value
                }
            }
            public var hasQuoteTokenSymbol:Bool {
                get {
                    return builderResult.hasQuoteTokenSymbol
                }
            }
            @discardableResult
            public func setQuoteTokenSymbol(_ value:String) -> Protocol.TickerStatisticsProto.Builder {
                self.quoteTokenSymbol = value
                return self
            }
            @discardableResult
            public func clearQuoteTokenSymbol() -> Protocol.TickerStatisticsProto.Builder{
                builderResult.hasQuoteTokenSymbol = false
                builderResult.quoteTokenSymbol = nil
                return self
            }
            ///tokenId
            public var tradeToken:String {
                get {
                    return builderResult.tradeToken
                }
                set (value) {
                    builderResult.hasTradeToken = true
                    builderResult.tradeToken = value
                }
            }
            public var hasTradeToken:Bool {
                get {
                    return builderResult.hasTradeToken
                }
            }
            @discardableResult
            public func setTradeToken(_ value:String) -> Protocol.TickerStatisticsProto.Builder {
                self.tradeToken = value
                return self
            }
            @discardableResult
            public func clearTradeToken() -> Protocol.TickerStatisticsProto.Builder{
                builderResult.hasTradeToken = false
                builderResult.tradeToken = nil
                return self
            }
            ///tokenId
            public var quoteToken:String {
                get {
                    return builderResult.quoteToken
                }
                set (value) {
                    builderResult.hasQuoteToken = true
                    builderResult.quoteToken = value
                }
            }
            public var hasQuoteToken:Bool {
                get {
                    return builderResult.hasQuoteToken
                }
            }
            @discardableResult
            public func setQuoteToken(_ value:String) -> Protocol.TickerStatisticsProto.Builder {
                self.quoteToken = value
                return self
            }
            @discardableResult
            public func clearQuoteToken() -> Protocol.TickerStatisticsProto.Builder{
                builderResult.hasQuoteToken = false
                builderResult.quoteToken = nil
                return self
            }
            ///价格
            public var openPrice:String {
                get {
                    return builderResult.openPrice
                }
                set (value) {
                    builderResult.hasOpenPrice = true
                    builderResult.openPrice = value
                }
            }
            public var hasOpenPrice:Bool {
                get {
                    return builderResult.hasOpenPrice
                }
            }
            @discardableResult
            public func setOpenPrice(_ value:String) -> Protocol.TickerStatisticsProto.Builder {
                self.openPrice = value
                return self
            }
            @discardableResult
            public func clearOpenPrice() -> Protocol.TickerStatisticsProto.Builder{
                builderResult.hasOpenPrice = false
                builderResult.openPrice = nil
                return self
            }
            ///价格
            public var prevClosePrice:String {
                get {
                    return builderResult.prevClosePrice
                }
                set (value) {
                    builderResult.hasPrevClosePrice = true
                    builderResult.prevClosePrice = value
                }
            }
            public var hasPrevClosePrice:Bool {
                get {
                    return builderResult.hasPrevClosePrice
                }
            }
            @discardableResult
            public func setPrevClosePrice(_ value:String) -> Protocol.TickerStatisticsProto.Builder {
                self.prevClosePrice = value
                return self
            }
            @discardableResult
            public func clearPrevClosePrice() -> Protocol.TickerStatisticsProto.Builder{
                builderResult.hasPrevClosePrice = false
                builderResult.prevClosePrice = nil
                return self
            }
            ///价格
            public var closePrice:String {
                get {
                    return builderResult.closePrice
                }
                set (value) {
                    builderResult.hasClosePrice = true
                    builderResult.closePrice = value
                }
            }
            public var hasClosePrice:Bool {
                get {
                    return builderResult.hasClosePrice
                }
            }
            @discardableResult
            public func setClosePrice(_ value:String) -> Protocol.TickerStatisticsProto.Builder {
                self.closePrice = value
                return self
            }
            @discardableResult
            public func clearClosePrice() -> Protocol.TickerStatisticsProto.Builder{
                builderResult.hasClosePrice = false
                builderResult.closePrice = nil
                return self
            }
            ///价格
            public var priceChange:String {
                get {
                    return builderResult.priceChange
                }
                set (value) {
                    builderResult.hasPriceChange = true
                    builderResult.priceChange = value
                }
            }
            public var hasPriceChange:Bool {
                get {
                    return builderResult.hasPriceChange
                }
            }
            @discardableResult
            public func setPriceChange(_ value:String) -> Protocol.TickerStatisticsProto.Builder {
                self.priceChange = value
                return self
            }
            @discardableResult
            public func clearPriceChange() -> Protocol.TickerStatisticsProto.Builder{
                builderResult.hasPriceChange = false
                builderResult.priceChange = nil
                return self
            }
            ///变化率
            public var priceChangePercent:Double {
                get {
                    return builderResult.priceChangePercent
                }
                set (value) {
                    builderResult.hasPriceChangePercent = true
                    builderResult.priceChangePercent = value
                }
            }
            public var hasPriceChangePercent:Bool {
                get {
                    return builderResult.hasPriceChangePercent
                }
            }
            @discardableResult
            public func setPriceChangePercent(_ value:Double) -> Protocol.TickerStatisticsProto.Builder {
                self.priceChangePercent = value
                return self
            }
            @discardableResult
            public func clearPriceChangePercent() -> Protocol.TickerStatisticsProto.Builder{
                builderResult.hasPriceChangePercent = false
                builderResult.priceChangePercent = nil
                return self
            }
            ///价格
            public var highPrice:String {
                get {
                    return builderResult.highPrice
                }
                set (value) {
                    builderResult.hasHighPrice = true
                    builderResult.highPrice = value
                }
            }
            public var hasHighPrice:Bool {
                get {
                    return builderResult.hasHighPrice
                }
            }
            @discardableResult
            public func setHighPrice(_ value:String) -> Protocol.TickerStatisticsProto.Builder {
                self.highPrice = value
                return self
            }
            @discardableResult
            public func clearHighPrice() -> Protocol.TickerStatisticsProto.Builder{
                builderResult.hasHighPrice = false
                builderResult.highPrice = nil
                return self
            }
            ///价格
            public var lowPrice:String {
                get {
                    return builderResult.lowPrice
                }
                set (value) {
                    builderResult.hasLowPrice = true
                    builderResult.lowPrice = value
                }
            }
            public var hasLowPrice:Bool {
                get {
                    return builderResult.hasLowPrice
                }
            }
            @discardableResult
            public func setLowPrice(_ value:String) -> Protocol.TickerStatisticsProto.Builder {
                self.lowPrice = value
                return self
            }
            @discardableResult
            public func clearLowPrice() -> Protocol.TickerStatisticsProto.Builder{
                builderResult.hasLowPrice = false
                builderResult.lowPrice = nil
                return self
            }
            ///数量
            public var quantity:String {
                get {
                    return builderResult.quantity
                }
                set (value) {
                    builderResult.hasQuantity = true
                    builderResult.quantity = value
                }
            }
            public var hasQuantity:Bool {
                get {
                    return builderResult.hasQuantity
                }
            }
            @discardableResult
            public func setQuantity(_ value:String) -> Protocol.TickerStatisticsProto.Builder {
                self.quantity = value
                return self
            }
            @discardableResult
            public func clearQuantity() -> Protocol.TickerStatisticsProto.Builder{
                builderResult.hasQuantity = false
                builderResult.quantity = nil
                return self
            }
            ///成交额
            public var amount:String {
                get {
                    return builderResult.amount
                }
                set (value) {
                    builderResult.hasAmount = true
                    builderResult.amount = value
                }
            }
            public var hasAmount:Bool {
                get {
                    return builderResult.hasAmount
                }
            }
            @discardableResult
            public func setAmount(_ value:String) -> Protocol.TickerStatisticsProto.Builder {
                self.amount = value
                return self
            }
            @discardableResult
            public func clearAmount() -> Protocol.TickerStatisticsProto.Builder{
                builderResult.hasAmount = false
                builderResult.amount = nil
                return self
            }
            ///price精度
            public var pricePrecision:Int32 {
                get {
                    return builderResult.pricePrecision
                }
                set (value) {
                    builderResult.hasPricePrecision = true
                    builderResult.pricePrecision = value
                }
            }
            public var hasPricePrecision:Bool {
                get {
                    return builderResult.hasPricePrecision
                }
            }
            @discardableResult
            public func setPricePrecision(_ value:Int32) -> Protocol.TickerStatisticsProto.Builder {
                self.pricePrecision = value
                return self
            }
            @discardableResult
            public func clearPricePrecision() -> Protocol.TickerStatisticsProto.Builder{
                builderResult.hasPricePrecision = false
                builderResult.pricePrecision = nil
                return self
            }
            ///quantity精度
            public var quantityPrecision:Int32 {
                get {
                    return builderResult.quantityPrecision
                }
                set (value) {
                    builderResult.hasQuantityPrecision = true
                    builderResult.quantityPrecision = value
                }
            }
            public var hasQuantityPrecision:Bool {
                get {
                    return builderResult.hasQuantityPrecision
                }
            }
            @discardableResult
            public func setQuantityPrecision(_ value:Int32) -> Protocol.TickerStatisticsProto.Builder {
                self.quantityPrecision = value
                return self
            }
            @discardableResult
            public func clearQuantityPrecision() -> Protocol.TickerStatisticsProto.Builder{
                builderResult.hasQuantityPrecision = false
                builderResult.quantityPrecision = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Protocol.TickerStatisticsProto.Builder {
                builderResult = Protocol.TickerStatisticsProto()
                return self
            }
            override public func clone() throws -> Protocol.TickerStatisticsProto.Builder {
                return try Protocol.TickerStatisticsProto.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Protocol.TickerStatisticsProto {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Protocol.TickerStatisticsProto {
                let returnMe:Protocol.TickerStatisticsProto = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Protocol.TickerStatisticsProto) throws -> Protocol.TickerStatisticsProto.Builder {
                if other == Protocol.TickerStatisticsProto() {
                    return self
                }
                if other.hasSymbol {
                    symbol = other.symbol
                }
                if other.hasTradeTokenSymbol {
                    tradeTokenSymbol = other.tradeTokenSymbol
                }
                if other.hasQuoteTokenSymbol {
                    quoteTokenSymbol = other.quoteTokenSymbol
                }
                if other.hasTradeToken {
                    tradeToken = other.tradeToken
                }
                if other.hasQuoteToken {
                    quoteToken = other.quoteToken
                }
                if other.hasOpenPrice {
                    openPrice = other.openPrice
                }
                if other.hasPrevClosePrice {
                    prevClosePrice = other.prevClosePrice
                }
                if other.hasClosePrice {
                    closePrice = other.closePrice
                }
                if other.hasPriceChange {
                    priceChange = other.priceChange
                }
                if other.hasPriceChangePercent {
                    priceChangePercent = other.priceChangePercent
                }
                if other.hasHighPrice {
                    highPrice = other.highPrice
                }
                if other.hasLowPrice {
                    lowPrice = other.lowPrice
                }
                if other.hasQuantity {
                    quantity = other.quantity
                }
                if other.hasAmount {
                    amount = other.amount
                }
                if other.hasPricePrecision {
                    pricePrecision = other.pricePrecision
                }
                if other.hasQuantityPrecision {
                    quantityPrecision = other.quantityPrecision
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Protocol.TickerStatisticsProto.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.TickerStatisticsProto.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        symbol = try codedInputStream.readString()

                    case 18:
                        tradeTokenSymbol = try codedInputStream.readString()

                    case 26:
                        quoteTokenSymbol = try codedInputStream.readString()

                    case 34:
                        tradeToken = try codedInputStream.readString()

                    case 42:
                        quoteToken = try codedInputStream.readString()

                    case 50:
                        openPrice = try codedInputStream.readString()

                    case 58:
                        prevClosePrice = try codedInputStream.readString()

                    case 66:
                        closePrice = try codedInputStream.readString()

                    case 74:
                        priceChange = try codedInputStream.readString()

                    case 82:
                        priceChangePercent = try codedInputStream.readDouble()

                    case 90:
                        highPrice = try codedInputStream.readString()

                    case 98:
                        lowPrice = try codedInputStream.readString()

                    case 106:
                        quantity = try codedInputStream.readString()

                    case 114:
                        amount = try codedInputStream.readString()

                    case 120:
                        pricePrecision = try codedInputStream.readInt32()

                    case 128:
                        quantityPrecision = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Protocol.TickerStatisticsProto.Builder {
                let resultDecodedBuilder = Protocol.TickerStatisticsProto.Builder()
                if let jsonValueSymbol = jsonMap["symbol"] as? String {
                    resultDecodedBuilder.symbol = jsonValueSymbol
                }
                if let jsonValueTradeTokenSymbol = jsonMap["tradeTokenSymbol"] as? String {
                    resultDecodedBuilder.tradeTokenSymbol = jsonValueTradeTokenSymbol
                }
                if let jsonValueQuoteTokenSymbol = jsonMap["quoteTokenSymbol"] as? String {
                    resultDecodedBuilder.quoteTokenSymbol = jsonValueQuoteTokenSymbol
                }
                if let jsonValueTradeToken = jsonMap["tradeToken"] as? String {
                    resultDecodedBuilder.tradeToken = jsonValueTradeToken
                }
                if let jsonValueQuoteToken = jsonMap["quoteToken"] as? String {
                    resultDecodedBuilder.quoteToken = jsonValueQuoteToken
                }
                if let jsonValueOpenPrice = jsonMap["openPrice"] as? String {
                    resultDecodedBuilder.openPrice = jsonValueOpenPrice
                }
                if let jsonValuePrevClosePrice = jsonMap["prevClosePrice"] as? String {
                    resultDecodedBuilder.prevClosePrice = jsonValuePrevClosePrice
                }
                if let jsonValueClosePrice = jsonMap["closePrice"] as? String {
                    resultDecodedBuilder.closePrice = jsonValueClosePrice
                }
                if let jsonValuePriceChange = jsonMap["priceChange"] as? String {
                    resultDecodedBuilder.priceChange = jsonValuePriceChange
                }
                if let jsonValuePriceChangePercent = jsonMap["priceChangePercent"] as? Double {
                    resultDecodedBuilder.priceChangePercent = jsonValuePriceChangePercent
                }
                if let jsonValueHighPrice = jsonMap["highPrice"] as? String {
                    resultDecodedBuilder.highPrice = jsonValueHighPrice
                }
                if let jsonValueLowPrice = jsonMap["lowPrice"] as? String {
                    resultDecodedBuilder.lowPrice = jsonValueLowPrice
                }
                if let jsonValueQuantity = jsonMap["quantity"] as? String {
                    resultDecodedBuilder.quantity = jsonValueQuantity
                }
                if let jsonValueAmount = jsonMap["amount"] as? String {
                    resultDecodedBuilder.amount = jsonValueAmount
                }
                if let jsonValuePricePrecision = jsonMap["pricePrecision"] as? Int {
                    resultDecodedBuilder.pricePrecision = Int32(jsonValuePricePrecision)
                } else if let jsonValuePricePrecision = jsonMap["pricePrecision"] as? String {
                    resultDecodedBuilder.pricePrecision = Int32(jsonValuePricePrecision)!
                }
                if let jsonValueQuantityPrecision = jsonMap["quantityPrecision"] as? Int {
                    resultDecodedBuilder.quantityPrecision = Int32(jsonValueQuantityPrecision)
                } else if let jsonValueQuantityPrecision = jsonMap["quantityPrecision"] as? String {
                    resultDecodedBuilder.quantityPrecision = Int32(jsonValueQuantityPrecision)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Protocol.TickerStatisticsProto.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Protocol.TickerStatisticsProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TradeListProto : GeneratedMessage {
        public typealias BuilderType = Protocol.TradeListProto.Builder

        public static func == (lhs: Protocol.TradeListProto, rhs: Protocol.TradeListProto) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.trade == rhs.trade)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var trade:Array<Protocol.TradeProto>  = Array<Protocol.TradeProto>()
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementTrade in trade {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementTrade)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementTrade in trade {
                serialize_size += oneElementTrade.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Protocol.TradeListProto.Builder {
            return Protocol.TradeListProto.classBuilder() as! Protocol.TradeListProto.Builder
        }
        public func getBuilder() -> Protocol.TradeListProto.Builder {
            return classBuilder() as! Protocol.TradeListProto.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Protocol.TradeListProto.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Protocol.TradeListProto.Builder()
        }
        public func toBuilder() throws -> Protocol.TradeListProto.Builder {
            return try Protocol.TradeListProto.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Protocol.TradeListProto) throws -> Protocol.TradeListProto.Builder {
            return try Protocol.TradeListProto.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !trade.isEmpty {
                var jsonArrayTrade:Array<Dictionary<String,Any>> = []
                for oneValueTrade in trade {
                    let ecodedMessageTrade = try oneValueTrade.encode()
                    jsonArrayTrade.append(ecodedMessageTrade)
                }
                jsonMap["trade"] = jsonArrayTrade
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Protocol.TradeListProto {
            return try Protocol.TradeListProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Protocol.TradeListProto {
            return try Protocol.TradeListProto.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var tradeElementIndex:Int = 0
            for oneElementTrade in trade {
                output += "\(indent) trade[\(tradeElementIndex)] {\n"
                output += try oneElementTrade.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                tradeElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementTrade in trade {
                    hashCode = (hashCode &* 31) &+ oneElementTrade.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Protocol.TradeListProto"
        }
        override public func className() -> String {
            return "Protocol.TradeListProto"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Protocol.TradeListProto = Protocol.TradeListProto()
            public func getMessage() -> Protocol.TradeListProto {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var trade:Array<Protocol.TradeProto> {
                get {
                    return builderResult.trade
                }
                set (value) {
                    builderResult.trade = value
                }
            }
            @discardableResult
            public func setTrade(_ value:Array<Protocol.TradeProto>) -> Protocol.TradeListProto.Builder {
                self.trade = value
                return self
            }
            @discardableResult
            public func clearTrade() -> Protocol.TradeListProto.Builder {
                builderResult.trade.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Protocol.TradeListProto.Builder {
                builderResult = Protocol.TradeListProto()
                return self
            }
            override public func clone() throws -> Protocol.TradeListProto.Builder {
                return try Protocol.TradeListProto.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Protocol.TradeListProto {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Protocol.TradeListProto {
                let returnMe:Protocol.TradeListProto = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Protocol.TradeListProto) throws -> Protocol.TradeListProto.Builder {
                if other == Protocol.TradeListProto() {
                    return self
                }
                if !other.trade.isEmpty  {
                     builderResult.trade += other.trade
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Protocol.TradeListProto.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.TradeListProto.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Protocol.TradeProto.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        trade.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Protocol.TradeListProto.Builder {
                let resultDecodedBuilder = Protocol.TradeListProto.Builder()
                if let jsonValueTrade = jsonMap["trade"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayTrade:Array<Protocol.TradeProto> = []
                    for oneValueTrade in jsonValueTrade {
                        let messageFromStringTrade = try Protocol.TradeProto.Builder.decodeToBuilder(jsonMap:oneValueTrade).build()

                        jsonArrayTrade.append(messageFromStringTrade)
                    }
                    resultDecodedBuilder.trade = jsonArrayTrade
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Protocol.TradeListProto.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Protocol.TradeListProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class TradeProto : GeneratedMessage {
        public typealias BuilderType = Protocol.TradeProto.Builder

        public static func == (lhs: Protocol.TradeProto, rhs: Protocol.TradeProto) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTradeId == rhs.hasTradeId) && (!lhs.hasTradeId || lhs.tradeId == rhs.tradeId)
            fieldCheck = fieldCheck && (lhs.hasSymbol == rhs.hasSymbol) && (!lhs.hasSymbol || lhs.symbol == rhs.symbol)
            fieldCheck = fieldCheck && (lhs.hasTradeTokenSymbol == rhs.hasTradeTokenSymbol) && (!lhs.hasTradeTokenSymbol || lhs.tradeTokenSymbol == rhs.tradeTokenSymbol)
            fieldCheck = fieldCheck && (lhs.hasQuoteTokenSymbol == rhs.hasQuoteTokenSymbol) && (!lhs.hasQuoteTokenSymbol || lhs.quoteTokenSymbol == rhs.quoteTokenSymbol)
            fieldCheck = fieldCheck && (lhs.hasTradeToken == rhs.hasTradeToken) && (!lhs.hasTradeToken || lhs.tradeToken == rhs.tradeToken)
            fieldCheck = fieldCheck && (lhs.hasQuoteToken == rhs.hasQuoteToken) && (!lhs.hasQuoteToken || lhs.quoteToken == rhs.quoteToken)
            fieldCheck = fieldCheck && (lhs.hasPrice == rhs.hasPrice) && (!lhs.hasPrice || lhs.price == rhs.price)
            fieldCheck = fieldCheck && (lhs.hasQuantity == rhs.hasQuantity) && (!lhs.hasQuantity || lhs.quantity == rhs.quantity)
            fieldCheck = fieldCheck && (lhs.hasAmount == rhs.hasAmount) && (!lhs.hasAmount || lhs.amount == rhs.amount)
            fieldCheck = fieldCheck && (lhs.hasTime == rhs.hasTime) && (!lhs.hasTime || lhs.time == rhs.time)
            fieldCheck = fieldCheck && (lhs.hasSide == rhs.hasSide) && (!lhs.hasSide || lhs.side == rhs.side)
            fieldCheck = fieldCheck && (lhs.hasBuyerOrderId == rhs.hasBuyerOrderId) && (!lhs.hasBuyerOrderId || lhs.buyerOrderId == rhs.buyerOrderId)
            fieldCheck = fieldCheck && (lhs.hasSellerOrderId == rhs.hasSellerOrderId) && (!lhs.hasSellerOrderId || lhs.sellerOrderId == rhs.sellerOrderId)
            fieldCheck = fieldCheck && (lhs.hasBuyFee == rhs.hasBuyFee) && (!lhs.hasBuyFee || lhs.buyFee == rhs.buyFee)
            fieldCheck = fieldCheck && (lhs.hasSellFee == rhs.hasSellFee) && (!lhs.hasSellFee || lhs.sellFee == rhs.sellFee)
            fieldCheck = fieldCheck && (lhs.hasBlockHeight == rhs.hasBlockHeight) && (!lhs.hasBlockHeight || lhs.blockHeight == rhs.blockHeight)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var tradeId:String! = nil
        public fileprivate(set) var hasTradeId:Bool = false

        ///symbol
        public fileprivate(set) var symbol:String! = nil
        public fileprivate(set) var hasSymbol:Bool = false

        ///symbol
        public fileprivate(set) var tradeTokenSymbol:String! = nil
        public fileprivate(set) var hasTradeTokenSymbol:Bool = false

        ///symbol
        public fileprivate(set) var quoteTokenSymbol:String! = nil
        public fileprivate(set) var hasQuoteTokenSymbol:Bool = false

        ///tokenId
        public fileprivate(set) var tradeToken:String! = nil
        public fileprivate(set) var hasTradeToken:Bool = false

        ///tokenId
        public fileprivate(set) var quoteToken:String! = nil
        public fileprivate(set) var hasQuoteToken:Bool = false

        ///price
        public fileprivate(set) var price:String! = nil
        public fileprivate(set) var hasPrice:Bool = false

        ///quantity
        public fileprivate(set) var quantity:String! = nil
        public fileprivate(set) var hasQuantity:Bool = false

        ///amount
        public fileprivate(set) var amount:String! = nil
        public fileprivate(set) var hasAmount:Bool = false

        ///time
        public fileprivate(set) var time:Int64! = nil
        public fileprivate(set) var hasTime:Bool = false

        ///side
        public fileprivate(set) var side:Int32! = nil
        public fileprivate(set) var hasSide:Bool = false

        ///orderId
        public fileprivate(set) var buyerOrderId:String! = nil
        public fileprivate(set) var hasBuyerOrderId:Bool = false

        ///orderId
        public fileprivate(set) var sellerOrderId:String! = nil
        public fileprivate(set) var hasSellerOrderId:Bool = false

        ///fee
        public fileprivate(set) var buyFee:String! = nil
        public fileprivate(set) var hasBuyFee:Bool = false

        ///fee
        public fileprivate(set) var sellFee:String! = nil
        public fileprivate(set) var hasSellFee:Bool = false

        ///height
        public fileprivate(set) var blockHeight:Int64! = nil
        public fileprivate(set) var hasBlockHeight:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTradeId {
                try codedOutputStream.writeString(fieldNumber: 1, value:tradeId)
            }
            if hasSymbol {
                try codedOutputStream.writeString(fieldNumber: 2, value:symbol)
            }
            if hasTradeTokenSymbol {
                try codedOutputStream.writeString(fieldNumber: 3, value:tradeTokenSymbol)
            }
            if hasQuoteTokenSymbol {
                try codedOutputStream.writeString(fieldNumber: 4, value:quoteTokenSymbol)
            }
            if hasTradeToken {
                try codedOutputStream.writeString(fieldNumber: 5, value:tradeToken)
            }
            if hasQuoteToken {
                try codedOutputStream.writeString(fieldNumber: 6, value:quoteToken)
            }
            if hasPrice {
                try codedOutputStream.writeString(fieldNumber: 7, value:price)
            }
            if hasQuantity {
                try codedOutputStream.writeString(fieldNumber: 8, value:quantity)
            }
            if hasAmount {
                try codedOutputStream.writeString(fieldNumber: 9, value:amount)
            }
            if hasTime {
                try codedOutputStream.writeInt64(fieldNumber: 10, value:time)
            }
            if hasSide {
                try codedOutputStream.writeInt32(fieldNumber: 11, value:side)
            }
            if hasBuyerOrderId {
                try codedOutputStream.writeString(fieldNumber: 12, value:buyerOrderId)
            }
            if hasSellerOrderId {
                try codedOutputStream.writeString(fieldNumber: 13, value:sellerOrderId)
            }
            if hasBuyFee {
                try codedOutputStream.writeString(fieldNumber: 14, value:buyFee)
            }
            if hasSellFee {
                try codedOutputStream.writeString(fieldNumber: 15, value:sellFee)
            }
            if hasBlockHeight {
                try codedOutputStream.writeInt64(fieldNumber: 16, value:blockHeight)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTradeId {
                serialize_size += tradeId.computeStringSize(fieldNumber: 1)
            }
            if hasSymbol {
                serialize_size += symbol.computeStringSize(fieldNumber: 2)
            }
            if hasTradeTokenSymbol {
                serialize_size += tradeTokenSymbol.computeStringSize(fieldNumber: 3)
            }
            if hasQuoteTokenSymbol {
                serialize_size += quoteTokenSymbol.computeStringSize(fieldNumber: 4)
            }
            if hasTradeToken {
                serialize_size += tradeToken.computeStringSize(fieldNumber: 5)
            }
            if hasQuoteToken {
                serialize_size += quoteToken.computeStringSize(fieldNumber: 6)
            }
            if hasPrice {
                serialize_size += price.computeStringSize(fieldNumber: 7)
            }
            if hasQuantity {
                serialize_size += quantity.computeStringSize(fieldNumber: 8)
            }
            if hasAmount {
                serialize_size += amount.computeStringSize(fieldNumber: 9)
            }
            if hasTime {
                serialize_size += time.computeInt64Size(fieldNumber: 10)
            }
            if hasSide {
                serialize_size += side.computeInt32Size(fieldNumber: 11)
            }
            if hasBuyerOrderId {
                serialize_size += buyerOrderId.computeStringSize(fieldNumber: 12)
            }
            if hasSellerOrderId {
                serialize_size += sellerOrderId.computeStringSize(fieldNumber: 13)
            }
            if hasBuyFee {
                serialize_size += buyFee.computeStringSize(fieldNumber: 14)
            }
            if hasSellFee {
                serialize_size += sellFee.computeStringSize(fieldNumber: 15)
            }
            if hasBlockHeight {
                serialize_size += blockHeight.computeInt64Size(fieldNumber: 16)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Protocol.TradeProto.Builder {
            return Protocol.TradeProto.classBuilder() as! Protocol.TradeProto.Builder
        }
        public func getBuilder() -> Protocol.TradeProto.Builder {
            return classBuilder() as! Protocol.TradeProto.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Protocol.TradeProto.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Protocol.TradeProto.Builder()
        }
        public func toBuilder() throws -> Protocol.TradeProto.Builder {
            return try Protocol.TradeProto.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Protocol.TradeProto) throws -> Protocol.TradeProto.Builder {
            return try Protocol.TradeProto.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTradeId {
                jsonMap["tradeId"] = tradeId
            }
            if hasSymbol {
                jsonMap["symbol"] = symbol
            }
            if hasTradeTokenSymbol {
                jsonMap["tradeTokenSymbol"] = tradeTokenSymbol
            }
            if hasQuoteTokenSymbol {
                jsonMap["quoteTokenSymbol"] = quoteTokenSymbol
            }
            if hasTradeToken {
                jsonMap["tradeToken"] = tradeToken
            }
            if hasQuoteToken {
                jsonMap["quoteToken"] = quoteToken
            }
            if hasPrice {
                jsonMap["price"] = price
            }
            if hasQuantity {
                jsonMap["quantity"] = quantity
            }
            if hasAmount {
                jsonMap["amount"] = amount
            }
            if hasTime {
                jsonMap["time"] = "\(time!)"
            }
            if hasSide {
                jsonMap["side"] = Int(side)
            }
            if hasBuyerOrderId {
                jsonMap["buyerOrderId"] = buyerOrderId
            }
            if hasSellerOrderId {
                jsonMap["sellerOrderId"] = sellerOrderId
            }
            if hasBuyFee {
                jsonMap["buyFee"] = buyFee
            }
            if hasSellFee {
                jsonMap["sellFee"] = sellFee
            }
            if hasBlockHeight {
                jsonMap["blockHeight"] = "\(blockHeight!)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Protocol.TradeProto {
            return try Protocol.TradeProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Protocol.TradeProto {
            return try Protocol.TradeProto.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTradeId {
                output += "\(indent) tradeId: \(String(describing: tradeId)) \n"
            }
            if hasSymbol {
                output += "\(indent) symbol: \(String(describing: symbol)) \n"
            }
            if hasTradeTokenSymbol {
                output += "\(indent) tradeTokenSymbol: \(String(describing: tradeTokenSymbol)) \n"
            }
            if hasQuoteTokenSymbol {
                output += "\(indent) quoteTokenSymbol: \(String(describing: quoteTokenSymbol)) \n"
            }
            if hasTradeToken {
                output += "\(indent) tradeToken: \(String(describing: tradeToken)) \n"
            }
            if hasQuoteToken {
                output += "\(indent) quoteToken: \(String(describing: quoteToken)) \n"
            }
            if hasPrice {
                output += "\(indent) price: \(String(describing: price)) \n"
            }
            if hasQuantity {
                output += "\(indent) quantity: \(String(describing: quantity)) \n"
            }
            if hasAmount {
                output += "\(indent) amount: \(String(describing: amount)) \n"
            }
            if hasTime {
                output += "\(indent) time: \(String(describing: time)) \n"
            }
            if hasSide {
                output += "\(indent) side: \(String(describing: side)) \n"
            }
            if hasBuyerOrderId {
                output += "\(indent) buyerOrderId: \(String(describing: buyerOrderId)) \n"
            }
            if hasSellerOrderId {
                output += "\(indent) sellerOrderId: \(String(describing: sellerOrderId)) \n"
            }
            if hasBuyFee {
                output += "\(indent) buyFee: \(String(describing: buyFee)) \n"
            }
            if hasSellFee {
                output += "\(indent) sellFee: \(String(describing: sellFee)) \n"
            }
            if hasBlockHeight {
                output += "\(indent) blockHeight: \(String(describing: blockHeight)) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTradeId {
                    hashCode = (hashCode &* 31) &+ tradeId.hashValue
                }
                if hasSymbol {
                    hashCode = (hashCode &* 31) &+ symbol.hashValue
                }
                if hasTradeTokenSymbol {
                    hashCode = (hashCode &* 31) &+ tradeTokenSymbol.hashValue
                }
                if hasQuoteTokenSymbol {
                    hashCode = (hashCode &* 31) &+ quoteTokenSymbol.hashValue
                }
                if hasTradeToken {
                    hashCode = (hashCode &* 31) &+ tradeToken.hashValue
                }
                if hasQuoteToken {
                    hashCode = (hashCode &* 31) &+ quoteToken.hashValue
                }
                if hasPrice {
                    hashCode = (hashCode &* 31) &+ price.hashValue
                }
                if hasQuantity {
                    hashCode = (hashCode &* 31) &+ quantity.hashValue
                }
                if hasAmount {
                    hashCode = (hashCode &* 31) &+ amount.hashValue
                }
                if hasTime {
                    hashCode = (hashCode &* 31) &+ time.hashValue
                }
                if hasSide {
                    hashCode = (hashCode &* 31) &+ side.hashValue
                }
                if hasBuyerOrderId {
                    hashCode = (hashCode &* 31) &+ buyerOrderId.hashValue
                }
                if hasSellerOrderId {
                    hashCode = (hashCode &* 31) &+ sellerOrderId.hashValue
                }
                if hasBuyFee {
                    hashCode = (hashCode &* 31) &+ buyFee.hashValue
                }
                if hasSellFee {
                    hashCode = (hashCode &* 31) &+ sellFee.hashValue
                }
                if hasBlockHeight {
                    hashCode = (hashCode &* 31) &+ blockHeight.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Protocol.TradeProto"
        }
        override public func className() -> String {
            return "Protocol.TradeProto"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Protocol.TradeProto = Protocol.TradeProto()
            public func getMessage() -> Protocol.TradeProto {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var tradeId:String {
                get {
                    return builderResult.tradeId
                }
                set (value) {
                    builderResult.hasTradeId = true
                    builderResult.tradeId = value
                }
            }
            public var hasTradeId:Bool {
                get {
                    return builderResult.hasTradeId
                }
            }
            @discardableResult
            public func setTradeId(_ value:String) -> Protocol.TradeProto.Builder {
                self.tradeId = value
                return self
            }
            @discardableResult
            public func clearTradeId() -> Protocol.TradeProto.Builder{
                builderResult.hasTradeId = false
                builderResult.tradeId = nil
                return self
            }
            ///symbol
            public var symbol:String {
                get {
                    return builderResult.symbol
                }
                set (value) {
                    builderResult.hasSymbol = true
                    builderResult.symbol = value
                }
            }
            public var hasSymbol:Bool {
                get {
                    return builderResult.hasSymbol
                }
            }
            @discardableResult
            public func setSymbol(_ value:String) -> Protocol.TradeProto.Builder {
                self.symbol = value
                return self
            }
            @discardableResult
            public func clearSymbol() -> Protocol.TradeProto.Builder{
                builderResult.hasSymbol = false
                builderResult.symbol = nil
                return self
            }
            ///symbol
            public var tradeTokenSymbol:String {
                get {
                    return builderResult.tradeTokenSymbol
                }
                set (value) {
                    builderResult.hasTradeTokenSymbol = true
                    builderResult.tradeTokenSymbol = value
                }
            }
            public var hasTradeTokenSymbol:Bool {
                get {
                    return builderResult.hasTradeTokenSymbol
                }
            }
            @discardableResult
            public func setTradeTokenSymbol(_ value:String) -> Protocol.TradeProto.Builder {
                self.tradeTokenSymbol = value
                return self
            }
            @discardableResult
            public func clearTradeTokenSymbol() -> Protocol.TradeProto.Builder{
                builderResult.hasTradeTokenSymbol = false
                builderResult.tradeTokenSymbol = nil
                return self
            }
            ///symbol
            public var quoteTokenSymbol:String {
                get {
                    return builderResult.quoteTokenSymbol
                }
                set (value) {
                    builderResult.hasQuoteTokenSymbol = true
                    builderResult.quoteTokenSymbol = value
                }
            }
            public var hasQuoteTokenSymbol:Bool {
                get {
                    return builderResult.hasQuoteTokenSymbol
                }
            }
            @discardableResult
            public func setQuoteTokenSymbol(_ value:String) -> Protocol.TradeProto.Builder {
                self.quoteTokenSymbol = value
                return self
            }
            @discardableResult
            public func clearQuoteTokenSymbol() -> Protocol.TradeProto.Builder{
                builderResult.hasQuoteTokenSymbol = false
                builderResult.quoteTokenSymbol = nil
                return self
            }
            ///tokenId
            public var tradeToken:String {
                get {
                    return builderResult.tradeToken
                }
                set (value) {
                    builderResult.hasTradeToken = true
                    builderResult.tradeToken = value
                }
            }
            public var hasTradeToken:Bool {
                get {
                    return builderResult.hasTradeToken
                }
            }
            @discardableResult
            public func setTradeToken(_ value:String) -> Protocol.TradeProto.Builder {
                self.tradeToken = value
                return self
            }
            @discardableResult
            public func clearTradeToken() -> Protocol.TradeProto.Builder{
                builderResult.hasTradeToken = false
                builderResult.tradeToken = nil
                return self
            }
            ///tokenId
            public var quoteToken:String {
                get {
                    return builderResult.quoteToken
                }
                set (value) {
                    builderResult.hasQuoteToken = true
                    builderResult.quoteToken = value
                }
            }
            public var hasQuoteToken:Bool {
                get {
                    return builderResult.hasQuoteToken
                }
            }
            @discardableResult
            public func setQuoteToken(_ value:String) -> Protocol.TradeProto.Builder {
                self.quoteToken = value
                return self
            }
            @discardableResult
            public func clearQuoteToken() -> Protocol.TradeProto.Builder{
                builderResult.hasQuoteToken = false
                builderResult.quoteToken = nil
                return self
            }
            ///price
            public var price:String {
                get {
                    return builderResult.price
                }
                set (value) {
                    builderResult.hasPrice = true
                    builderResult.price = value
                }
            }
            public var hasPrice:Bool {
                get {
                    return builderResult.hasPrice
                }
            }
            @discardableResult
            public func setPrice(_ value:String) -> Protocol.TradeProto.Builder {
                self.price = value
                return self
            }
            @discardableResult
            public func clearPrice() -> Protocol.TradeProto.Builder{
                builderResult.hasPrice = false
                builderResult.price = nil
                return self
            }
            ///quantity
            public var quantity:String {
                get {
                    return builderResult.quantity
                }
                set (value) {
                    builderResult.hasQuantity = true
                    builderResult.quantity = value
                }
            }
            public var hasQuantity:Bool {
                get {
                    return builderResult.hasQuantity
                }
            }
            @discardableResult
            public func setQuantity(_ value:String) -> Protocol.TradeProto.Builder {
                self.quantity = value
                return self
            }
            @discardableResult
            public func clearQuantity() -> Protocol.TradeProto.Builder{
                builderResult.hasQuantity = false
                builderResult.quantity = nil
                return self
            }
            ///amount
            public var amount:String {
                get {
                    return builderResult.amount
                }
                set (value) {
                    builderResult.hasAmount = true
                    builderResult.amount = value
                }
            }
            public var hasAmount:Bool {
                get {
                    return builderResult.hasAmount
                }
            }
            @discardableResult
            public func setAmount(_ value:String) -> Protocol.TradeProto.Builder {
                self.amount = value
                return self
            }
            @discardableResult
            public func clearAmount() -> Protocol.TradeProto.Builder{
                builderResult.hasAmount = false
                builderResult.amount = nil
                return self
            }
            ///time
            public var time:Int64 {
                get {
                    return builderResult.time
                }
                set (value) {
                    builderResult.hasTime = true
                    builderResult.time = value
                }
            }
            public var hasTime:Bool {
                get {
                    return builderResult.hasTime
                }
            }
            @discardableResult
            public func setTime(_ value:Int64) -> Protocol.TradeProto.Builder {
                self.time = value
                return self
            }
            @discardableResult
            public func clearTime() -> Protocol.TradeProto.Builder{
                builderResult.hasTime = false
                builderResult.time = nil
                return self
            }
            ///side
            public var side:Int32 {
                get {
                    return builderResult.side
                }
                set (value) {
                    builderResult.hasSide = true
                    builderResult.side = value
                }
            }
            public var hasSide:Bool {
                get {
                    return builderResult.hasSide
                }
            }
            @discardableResult
            public func setSide(_ value:Int32) -> Protocol.TradeProto.Builder {
                self.side = value
                return self
            }
            @discardableResult
            public func clearSide() -> Protocol.TradeProto.Builder{
                builderResult.hasSide = false
                builderResult.side = nil
                return self
            }
            ///orderId
            public var buyerOrderId:String {
                get {
                    return builderResult.buyerOrderId
                }
                set (value) {
                    builderResult.hasBuyerOrderId = true
                    builderResult.buyerOrderId = value
                }
            }
            public var hasBuyerOrderId:Bool {
                get {
                    return builderResult.hasBuyerOrderId
                }
            }
            @discardableResult
            public func setBuyerOrderId(_ value:String) -> Protocol.TradeProto.Builder {
                self.buyerOrderId = value
                return self
            }
            @discardableResult
            public func clearBuyerOrderId() -> Protocol.TradeProto.Builder{
                builderResult.hasBuyerOrderId = false
                builderResult.buyerOrderId = nil
                return self
            }
            ///orderId
            public var sellerOrderId:String {
                get {
                    return builderResult.sellerOrderId
                }
                set (value) {
                    builderResult.hasSellerOrderId = true
                    builderResult.sellerOrderId = value
                }
            }
            public var hasSellerOrderId:Bool {
                get {
                    return builderResult.hasSellerOrderId
                }
            }
            @discardableResult
            public func setSellerOrderId(_ value:String) -> Protocol.TradeProto.Builder {
                self.sellerOrderId = value
                return self
            }
            @discardableResult
            public func clearSellerOrderId() -> Protocol.TradeProto.Builder{
                builderResult.hasSellerOrderId = false
                builderResult.sellerOrderId = nil
                return self
            }
            ///fee
            public var buyFee:String {
                get {
                    return builderResult.buyFee
                }
                set (value) {
                    builderResult.hasBuyFee = true
                    builderResult.buyFee = value
                }
            }
            public var hasBuyFee:Bool {
                get {
                    return builderResult.hasBuyFee
                }
            }
            @discardableResult
            public func setBuyFee(_ value:String) -> Protocol.TradeProto.Builder {
                self.buyFee = value
                return self
            }
            @discardableResult
            public func clearBuyFee() -> Protocol.TradeProto.Builder{
                builderResult.hasBuyFee = false
                builderResult.buyFee = nil
                return self
            }
            ///fee
            public var sellFee:String {
                get {
                    return builderResult.sellFee
                }
                set (value) {
                    builderResult.hasSellFee = true
                    builderResult.sellFee = value
                }
            }
            public var hasSellFee:Bool {
                get {
                    return builderResult.hasSellFee
                }
            }
            @discardableResult
            public func setSellFee(_ value:String) -> Protocol.TradeProto.Builder {
                self.sellFee = value
                return self
            }
            @discardableResult
            public func clearSellFee() -> Protocol.TradeProto.Builder{
                builderResult.hasSellFee = false
                builderResult.sellFee = nil
                return self
            }
            ///height
            public var blockHeight:Int64 {
                get {
                    return builderResult.blockHeight
                }
                set (value) {
                    builderResult.hasBlockHeight = true
                    builderResult.blockHeight = value
                }
            }
            public var hasBlockHeight:Bool {
                get {
                    return builderResult.hasBlockHeight
                }
            }
            @discardableResult
            public func setBlockHeight(_ value:Int64) -> Protocol.TradeProto.Builder {
                self.blockHeight = value
                return self
            }
            @discardableResult
            public func clearBlockHeight() -> Protocol.TradeProto.Builder{
                builderResult.hasBlockHeight = false
                builderResult.blockHeight = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Protocol.TradeProto.Builder {
                builderResult = Protocol.TradeProto()
                return self
            }
            override public func clone() throws -> Protocol.TradeProto.Builder {
                return try Protocol.TradeProto.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Protocol.TradeProto {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Protocol.TradeProto {
                let returnMe:Protocol.TradeProto = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Protocol.TradeProto) throws -> Protocol.TradeProto.Builder {
                if other == Protocol.TradeProto() {
                    return self
                }
                if other.hasTradeId {
                    tradeId = other.tradeId
                }
                if other.hasSymbol {
                    symbol = other.symbol
                }
                if other.hasTradeTokenSymbol {
                    tradeTokenSymbol = other.tradeTokenSymbol
                }
                if other.hasQuoteTokenSymbol {
                    quoteTokenSymbol = other.quoteTokenSymbol
                }
                if other.hasTradeToken {
                    tradeToken = other.tradeToken
                }
                if other.hasQuoteToken {
                    quoteToken = other.quoteToken
                }
                if other.hasPrice {
                    price = other.price
                }
                if other.hasQuantity {
                    quantity = other.quantity
                }
                if other.hasAmount {
                    amount = other.amount
                }
                if other.hasTime {
                    time = other.time
                }
                if other.hasSide {
                    side = other.side
                }
                if other.hasBuyerOrderId {
                    buyerOrderId = other.buyerOrderId
                }
                if other.hasSellerOrderId {
                    sellerOrderId = other.sellerOrderId
                }
                if other.hasBuyFee {
                    buyFee = other.buyFee
                }
                if other.hasSellFee {
                    sellFee = other.sellFee
                }
                if other.hasBlockHeight {
                    blockHeight = other.blockHeight
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Protocol.TradeProto.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.TradeProto.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        tradeId = try codedInputStream.readString()

                    case 18:
                        symbol = try codedInputStream.readString()

                    case 26:
                        tradeTokenSymbol = try codedInputStream.readString()

                    case 34:
                        quoteTokenSymbol = try codedInputStream.readString()

                    case 42:
                        tradeToken = try codedInputStream.readString()

                    case 50:
                        quoteToken = try codedInputStream.readString()

                    case 58:
                        price = try codedInputStream.readString()

                    case 66:
                        quantity = try codedInputStream.readString()

                    case 74:
                        amount = try codedInputStream.readString()

                    case 80:
                        time = try codedInputStream.readInt64()

                    case 88:
                        side = try codedInputStream.readInt32()

                    case 98:
                        buyerOrderId = try codedInputStream.readString()

                    case 106:
                        sellerOrderId = try codedInputStream.readString()

                    case 114:
                        buyFee = try codedInputStream.readString()

                    case 122:
                        sellFee = try codedInputStream.readString()

                    case 128:
                        blockHeight = try codedInputStream.readInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Protocol.TradeProto.Builder {
                let resultDecodedBuilder = Protocol.TradeProto.Builder()
                if let jsonValueTradeId = jsonMap["tradeId"] as? String {
                    resultDecodedBuilder.tradeId = jsonValueTradeId
                }
                if let jsonValueSymbol = jsonMap["symbol"] as? String {
                    resultDecodedBuilder.symbol = jsonValueSymbol
                }
                if let jsonValueTradeTokenSymbol = jsonMap["tradeTokenSymbol"] as? String {
                    resultDecodedBuilder.tradeTokenSymbol = jsonValueTradeTokenSymbol
                }
                if let jsonValueQuoteTokenSymbol = jsonMap["quoteTokenSymbol"] as? String {
                    resultDecodedBuilder.quoteTokenSymbol = jsonValueQuoteTokenSymbol
                }
                if let jsonValueTradeToken = jsonMap["tradeToken"] as? String {
                    resultDecodedBuilder.tradeToken = jsonValueTradeToken
                }
                if let jsonValueQuoteToken = jsonMap["quoteToken"] as? String {
                    resultDecodedBuilder.quoteToken = jsonValueQuoteToken
                }
                if let jsonValuePrice = jsonMap["price"] as? String {
                    resultDecodedBuilder.price = jsonValuePrice
                }
                if let jsonValueQuantity = jsonMap["quantity"] as? String {
                    resultDecodedBuilder.quantity = jsonValueQuantity
                }
                if let jsonValueAmount = jsonMap["amount"] as? String {
                    resultDecodedBuilder.amount = jsonValueAmount
                }
                if let jsonValueTime = jsonMap["time"] as? String {
                    resultDecodedBuilder.time = Int64(jsonValueTime)!
                } else if let jsonValueTime = jsonMap["time"] as? Int {
                    resultDecodedBuilder.time = Int64(jsonValueTime)
                }
                if let jsonValueSide = jsonMap["side"] as? Int {
                    resultDecodedBuilder.side = Int32(jsonValueSide)
                } else if let jsonValueSide = jsonMap["side"] as? String {
                    resultDecodedBuilder.side = Int32(jsonValueSide)!
                }
                if let jsonValueBuyerOrderId = jsonMap["buyerOrderId"] as? String {
                    resultDecodedBuilder.buyerOrderId = jsonValueBuyerOrderId
                }
                if let jsonValueSellerOrderId = jsonMap["sellerOrderId"] as? String {
                    resultDecodedBuilder.sellerOrderId = jsonValueSellerOrderId
                }
                if let jsonValueBuyFee = jsonMap["buyFee"] as? String {
                    resultDecodedBuilder.buyFee = jsonValueBuyFee
                }
                if let jsonValueSellFee = jsonMap["sellFee"] as? String {
                    resultDecodedBuilder.sellFee = jsonValueSellFee
                }
                if let jsonValueBlockHeight = jsonMap["blockHeight"] as? String {
                    resultDecodedBuilder.blockHeight = Int64(jsonValueBlockHeight)!
                } else if let jsonValueBlockHeight = jsonMap["blockHeight"] as? Int {
                    resultDecodedBuilder.blockHeight = Int64(jsonValueBlockHeight)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Protocol.TradeProto.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Protocol.TradeProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class KlineProto : GeneratedMessage {
        public typealias BuilderType = Protocol.KlineProto.Builder

        public static func == (lhs: Protocol.KlineProto, rhs: Protocol.KlineProto) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasT == rhs.hasT) && (!lhs.hasT || lhs.t == rhs.t)
            fieldCheck = fieldCheck && (lhs.hasC == rhs.hasC) && (!lhs.hasC || lhs.c == rhs.c)
            fieldCheck = fieldCheck && (lhs.hasO == rhs.hasO) && (!lhs.hasO || lhs.o == rhs.o)
            fieldCheck = fieldCheck && (lhs.hasH == rhs.hasH) && (!lhs.hasH || lhs.h == rhs.h)
            fieldCheck = fieldCheck && (lhs.hasL == rhs.hasL) && (!lhs.hasL || lhs.l == rhs.l)
            fieldCheck = fieldCheck && (lhs.hasV == rhs.hasV) && (!lhs.hasV || lhs.v == rhs.v)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var t:Int64! = nil
        public fileprivate(set) var hasT:Bool = false

        public fileprivate(set) var c:Double! = nil
        public fileprivate(set) var hasC:Bool = false

        public fileprivate(set) var o:Double! = nil
        public fileprivate(set) var hasO:Bool = false

        public fileprivate(set) var h:Double! = nil
        public fileprivate(set) var hasH:Bool = false

        public fileprivate(set) var l:Double! = nil
        public fileprivate(set) var hasL:Bool = false

        public fileprivate(set) var v:Double! = nil
        public fileprivate(set) var hasV:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasT {
                try codedOutputStream.writeInt64(fieldNumber: 1, value:t)
            }
            if hasC {
                try codedOutputStream.writeDouble(fieldNumber: 2, value:c)
            }
            if hasO {
                try codedOutputStream.writeDouble(fieldNumber: 3, value:o)
            }
            if hasH {
                try codedOutputStream.writeDouble(fieldNumber: 4, value:h)
            }
            if hasL {
                try codedOutputStream.writeDouble(fieldNumber: 5, value:l)
            }
            if hasV {
                try codedOutputStream.writeDouble(fieldNumber: 6, value:v)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasT {
                serialize_size += t.computeInt64Size(fieldNumber: 1)
            }
            if hasC {
                serialize_size += c.computeDoubleSize(fieldNumber: 2)
            }
            if hasO {
                serialize_size += o.computeDoubleSize(fieldNumber: 3)
            }
            if hasH {
                serialize_size += h.computeDoubleSize(fieldNumber: 4)
            }
            if hasL {
                serialize_size += l.computeDoubleSize(fieldNumber: 5)
            }
            if hasV {
                serialize_size += v.computeDoubleSize(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Protocol.KlineProto.Builder {
            return Protocol.KlineProto.classBuilder() as! Protocol.KlineProto.Builder
        }
        public func getBuilder() -> Protocol.KlineProto.Builder {
            return classBuilder() as! Protocol.KlineProto.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Protocol.KlineProto.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Protocol.KlineProto.Builder()
        }
        public func toBuilder() throws -> Protocol.KlineProto.Builder {
            return try Protocol.KlineProto.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Protocol.KlineProto) throws -> Protocol.KlineProto.Builder {
            return try Protocol.KlineProto.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasT {
                jsonMap["t"] = "\(t!)"
            }
            if hasC {
                jsonMap["c"] = Double(c)
            }
            if hasO {
                jsonMap["o"] = Double(o)
            }
            if hasH {
                jsonMap["h"] = Double(h)
            }
            if hasL {
                jsonMap["l"] = Double(l)
            }
            if hasV {
                jsonMap["v"] = Double(v)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Protocol.KlineProto {
            return try Protocol.KlineProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Protocol.KlineProto {
            return try Protocol.KlineProto.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasT {
                output += "\(indent) t: \(String(describing: t)) \n"
            }
            if hasC {
                output += "\(indent) c: \(String(describing: c)) \n"
            }
            if hasO {
                output += "\(indent) o: \(String(describing: o)) \n"
            }
            if hasH {
                output += "\(indent) h: \(String(describing: h)) \n"
            }
            if hasL {
                output += "\(indent) l: \(String(describing: l)) \n"
            }
            if hasV {
                output += "\(indent) v: \(String(describing: v)) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasT {
                    hashCode = (hashCode &* 31) &+ t.hashValue
                }
                if hasC {
                    hashCode = (hashCode &* 31) &+ c.hashValue
                }
                if hasO {
                    hashCode = (hashCode &* 31) &+ o.hashValue
                }
                if hasH {
                    hashCode = (hashCode &* 31) &+ h.hashValue
                }
                if hasL {
                    hashCode = (hashCode &* 31) &+ l.hashValue
                }
                if hasV {
                    hashCode = (hashCode &* 31) &+ v.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Protocol.KlineProto"
        }
        override public func className() -> String {
            return "Protocol.KlineProto"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Protocol.KlineProto = Protocol.KlineProto()
            public func getMessage() -> Protocol.KlineProto {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var t:Int64 {
                get {
                    return builderResult.t
                }
                set (value) {
                    builderResult.hasT = true
                    builderResult.t = value
                }
            }
            public var hasT:Bool {
                get {
                    return builderResult.hasT
                }
            }
            @discardableResult
            public func setT(_ value:Int64) -> Protocol.KlineProto.Builder {
                self.t = value
                return self
            }
            @discardableResult
            public func clearT() -> Protocol.KlineProto.Builder{
                builderResult.hasT = false
                builderResult.t = nil
                return self
            }
            public var c:Double {
                get {
                    return builderResult.c
                }
                set (value) {
                    builderResult.hasC = true
                    builderResult.c = value
                }
            }
            public var hasC:Bool {
                get {
                    return builderResult.hasC
                }
            }
            @discardableResult
            public func setC(_ value:Double) -> Protocol.KlineProto.Builder {
                self.c = value
                return self
            }
            @discardableResult
            public func clearC() -> Protocol.KlineProto.Builder{
                builderResult.hasC = false
                builderResult.c = nil
                return self
            }
            public var o:Double {
                get {
                    return builderResult.o
                }
                set (value) {
                    builderResult.hasO = true
                    builderResult.o = value
                }
            }
            public var hasO:Bool {
                get {
                    return builderResult.hasO
                }
            }
            @discardableResult
            public func setO(_ value:Double) -> Protocol.KlineProto.Builder {
                self.o = value
                return self
            }
            @discardableResult
            public func clearO() -> Protocol.KlineProto.Builder{
                builderResult.hasO = false
                builderResult.o = nil
                return self
            }
            public var h:Double {
                get {
                    return builderResult.h
                }
                set (value) {
                    builderResult.hasH = true
                    builderResult.h = value
                }
            }
            public var hasH:Bool {
                get {
                    return builderResult.hasH
                }
            }
            @discardableResult
            public func setH(_ value:Double) -> Protocol.KlineProto.Builder {
                self.h = value
                return self
            }
            @discardableResult
            public func clearH() -> Protocol.KlineProto.Builder{
                builderResult.hasH = false
                builderResult.h = nil
                return self
            }
            public var l:Double {
                get {
                    return builderResult.l
                }
                set (value) {
                    builderResult.hasL = true
                    builderResult.l = value
                }
            }
            public var hasL:Bool {
                get {
                    return builderResult.hasL
                }
            }
            @discardableResult
            public func setL(_ value:Double) -> Protocol.KlineProto.Builder {
                self.l = value
                return self
            }
            @discardableResult
            public func clearL() -> Protocol.KlineProto.Builder{
                builderResult.hasL = false
                builderResult.l = nil
                return self
            }
            public var v:Double {
                get {
                    return builderResult.v
                }
                set (value) {
                    builderResult.hasV = true
                    builderResult.v = value
                }
            }
            public var hasV:Bool {
                get {
                    return builderResult.hasV
                }
            }
            @discardableResult
            public func setV(_ value:Double) -> Protocol.KlineProto.Builder {
                self.v = value
                return self
            }
            @discardableResult
            public func clearV() -> Protocol.KlineProto.Builder{
                builderResult.hasV = false
                builderResult.v = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Protocol.KlineProto.Builder {
                builderResult = Protocol.KlineProto()
                return self
            }
            override public func clone() throws -> Protocol.KlineProto.Builder {
                return try Protocol.KlineProto.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Protocol.KlineProto {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Protocol.KlineProto {
                let returnMe:Protocol.KlineProto = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Protocol.KlineProto) throws -> Protocol.KlineProto.Builder {
                if other == Protocol.KlineProto() {
                    return self
                }
                if other.hasT {
                    t = other.t
                }
                if other.hasC {
                    c = other.c
                }
                if other.hasO {
                    o = other.o
                }
                if other.hasH {
                    h = other.h
                }
                if other.hasL {
                    l = other.l
                }
                if other.hasV {
                    v = other.v
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Protocol.KlineProto.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.KlineProto.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        t = try codedInputStream.readInt64()

                    case 17:
                        c = try codedInputStream.readDouble()

                    case 25:
                        o = try codedInputStream.readDouble()

                    case 33:
                        h = try codedInputStream.readDouble()

                    case 41:
                        l = try codedInputStream.readDouble()

                    case 49:
                        v = try codedInputStream.readDouble()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Protocol.KlineProto.Builder {
                let resultDecodedBuilder = Protocol.KlineProto.Builder()
                if let jsonValueT = jsonMap["t"] as? String {
                    resultDecodedBuilder.t = Int64(jsonValueT)!
                } else if let jsonValueT = jsonMap["t"] as? Int {
                    resultDecodedBuilder.t = Int64(jsonValueT)
                }
                if let jsonValueC = jsonMap["c"] as? Double {
                    resultDecodedBuilder.c = Double(jsonValueC)
                } else if let jsonValueC = jsonMap["c"] as? String {
                    resultDecodedBuilder.c = Double(jsonValueC)!
                }
                if let jsonValueO = jsonMap["o"] as? Double {
                    resultDecodedBuilder.o = Double(jsonValueO)
                } else if let jsonValueO = jsonMap["o"] as? String {
                    resultDecodedBuilder.o = Double(jsonValueO)!
                }
                if let jsonValueH = jsonMap["h"] as? Double {
                    resultDecodedBuilder.h = Double(jsonValueH)
                } else if let jsonValueH = jsonMap["h"] as? String {
                    resultDecodedBuilder.h = Double(jsonValueH)!
                }
                if let jsonValueL = jsonMap["l"] as? Double {
                    resultDecodedBuilder.l = Double(jsonValueL)
                } else if let jsonValueL = jsonMap["l"] as? String {
                    resultDecodedBuilder.l = Double(jsonValueL)!
                }
                if let jsonValueV = jsonMap["v"] as? Double {
                    resultDecodedBuilder.v = Double(jsonValueV)
                } else if let jsonValueV = jsonMap["v"] as? String {
                    resultDecodedBuilder.v = Double(jsonValueV)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Protocol.KlineProto.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Protocol.KlineProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class OrderProto : GeneratedMessage {
        public typealias BuilderType = Protocol.OrderProto.Builder

        public static func == (lhs: Protocol.OrderProto, rhs: Protocol.OrderProto) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOrderId == rhs.hasOrderId) && (!lhs.hasOrderId || lhs.orderId == rhs.orderId)
            fieldCheck = fieldCheck && (lhs.hasSymbol == rhs.hasSymbol) && (!lhs.hasSymbol || lhs.symbol == rhs.symbol)
            fieldCheck = fieldCheck && (lhs.hasTradeTokenSymbol == rhs.hasTradeTokenSymbol) && (!lhs.hasTradeTokenSymbol || lhs.tradeTokenSymbol == rhs.tradeTokenSymbol)
            fieldCheck = fieldCheck && (lhs.hasQuoteTokenSymbol == rhs.hasQuoteTokenSymbol) && (!lhs.hasQuoteTokenSymbol || lhs.quoteTokenSymbol == rhs.quoteTokenSymbol)
            fieldCheck = fieldCheck && (lhs.hasTradeToken == rhs.hasTradeToken) && (!lhs.hasTradeToken || lhs.tradeToken == rhs.tradeToken)
            fieldCheck = fieldCheck && (lhs.hasQuoteToken == rhs.hasQuoteToken) && (!lhs.hasQuoteToken || lhs.quoteToken == rhs.quoteToken)
            fieldCheck = fieldCheck && (lhs.hasSide == rhs.hasSide) && (!lhs.hasSide || lhs.side == rhs.side)
            fieldCheck = fieldCheck && (lhs.hasPrice == rhs.hasPrice) && (!lhs.hasPrice || lhs.price == rhs.price)
            fieldCheck = fieldCheck && (lhs.hasQuantity == rhs.hasQuantity) && (!lhs.hasQuantity || lhs.quantity == rhs.quantity)
            fieldCheck = fieldCheck && (lhs.hasAmount == rhs.hasAmount) && (!lhs.hasAmount || lhs.amount == rhs.amount)
            fieldCheck = fieldCheck && (lhs.hasExecutedQuantity == rhs.hasExecutedQuantity) && (!lhs.hasExecutedQuantity || lhs.executedQuantity == rhs.executedQuantity)
            fieldCheck = fieldCheck && (lhs.hasExecutedAmount == rhs.hasExecutedAmount) && (!lhs.hasExecutedAmount || lhs.executedAmount == rhs.executedAmount)
            fieldCheck = fieldCheck && (lhs.hasExecutedPercent == rhs.hasExecutedPercent) && (!lhs.hasExecutedPercent || lhs.executedPercent == rhs.executedPercent)
            fieldCheck = fieldCheck && (lhs.hasExecutedAvgPrice == rhs.hasExecutedAvgPrice) && (!lhs.hasExecutedAvgPrice || lhs.executedAvgPrice == rhs.executedAvgPrice)
            fieldCheck = fieldCheck && (lhs.hasFee == rhs.hasFee) && (!lhs.hasFee || lhs.fee == rhs.fee)
            fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
            fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
            fieldCheck = fieldCheck && (lhs.hasCreateTime == rhs.hasCreateTime) && (!lhs.hasCreateTime || lhs.createTime == rhs.createTime)
            fieldCheck = fieldCheck && (lhs.hasAddress == rhs.hasAddress) && (!lhs.hasAddress || lhs.address == rhs.address)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///订单ID
        public fileprivate(set) var orderId:String! = nil
        public fileprivate(set) var hasOrderId:Bool = false

        ///symbol
        public fileprivate(set) var symbol:String! = nil
        public fileprivate(set) var hasSymbol:Bool = false

        ///symbol
        public fileprivate(set) var tradeTokenSymbol:String! = nil
        public fileprivate(set) var hasTradeTokenSymbol:Bool = false

        ///symbol
        public fileprivate(set) var quoteTokenSymbol:String! = nil
        public fileprivate(set) var hasQuoteTokenSymbol:Bool = false

        ///tokenId
        public fileprivate(set) var tradeToken:String! = nil
        public fileprivate(set) var hasTradeToken:Bool = false

        ///tokenId
        public fileprivate(set) var quoteToken:String! = nil
        public fileprivate(set) var hasQuoteToken:Bool = false

        ///方向
        public fileprivate(set) var side:Int32! = nil
        public fileprivate(set) var hasSide:Bool = false

        ///价格
        public fileprivate(set) var price:String! = nil
        public fileprivate(set) var hasPrice:Bool = false

        ///数量
        public fileprivate(set) var quantity:String! = nil
        public fileprivate(set) var hasQuantity:Bool = false

        ///交易量
        public fileprivate(set) var amount:String! = nil
        public fileprivate(set) var hasAmount:Bool = false

        ///成交Quantity
        public fileprivate(set) var executedQuantity:String! = nil
        public fileprivate(set) var hasExecutedQuantity:Bool = false

        ///成交Amount
        public fileprivate(set) var executedAmount:String! = nil
        public fileprivate(set) var hasExecutedAmount:Bool = false

        ///成交率
        public fileprivate(set) var executedPercent:String! = nil
        public fileprivate(set) var hasExecutedPercent:Bool = false

        ///均价
        public fileprivate(set) var executedAvgPrice:String! = nil
        public fileprivate(set) var hasExecutedAvgPrice:Bool = false

        ///手续费
        public fileprivate(set) var fee:String! = nil
        public fileprivate(set) var hasFee:Bool = false

        ///状态
        public fileprivate(set) var status:Int32! = nil
        public fileprivate(set) var hasStatus:Bool = false

        ///类型
        public fileprivate(set) var type:Int32! = nil
        public fileprivate(set) var hasType:Bool = false

        ///时间
        public fileprivate(set) var createTime:Int64! = nil
        public fileprivate(set) var hasCreateTime:Bool = false

        ///地址
        public fileprivate(set) var address:String! = nil
        public fileprivate(set) var hasAddress:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOrderId {
                try codedOutputStream.writeString(fieldNumber: 1, value:orderId)
            }
            if hasSymbol {
                try codedOutputStream.writeString(fieldNumber: 2, value:symbol)
            }
            if hasTradeTokenSymbol {
                try codedOutputStream.writeString(fieldNumber: 3, value:tradeTokenSymbol)
            }
            if hasQuoteTokenSymbol {
                try codedOutputStream.writeString(fieldNumber: 4, value:quoteTokenSymbol)
            }
            if hasTradeToken {
                try codedOutputStream.writeString(fieldNumber: 5, value:tradeToken)
            }
            if hasQuoteToken {
                try codedOutputStream.writeString(fieldNumber: 6, value:quoteToken)
            }
            if hasSide {
                try codedOutputStream.writeInt32(fieldNumber: 7, value:side)
            }
            if hasPrice {
                try codedOutputStream.writeString(fieldNumber: 8, value:price)
            }
            if hasQuantity {
                try codedOutputStream.writeString(fieldNumber: 9, value:quantity)
            }
            if hasAmount {
                try codedOutputStream.writeString(fieldNumber: 10, value:amount)
            }
            if hasExecutedQuantity {
                try codedOutputStream.writeString(fieldNumber: 11, value:executedQuantity)
            }
            if hasExecutedAmount {
                try codedOutputStream.writeString(fieldNumber: 12, value:executedAmount)
            }
            if hasExecutedPercent {
                try codedOutputStream.writeString(fieldNumber: 13, value:executedPercent)
            }
            if hasExecutedAvgPrice {
                try codedOutputStream.writeString(fieldNumber: 14, value:executedAvgPrice)
            }
            if hasFee {
                try codedOutputStream.writeString(fieldNumber: 15, value:fee)
            }
            if hasStatus {
                try codedOutputStream.writeInt32(fieldNumber: 16, value:status)
            }
            if hasType {
                try codedOutputStream.writeInt32(fieldNumber: 17, value:type)
            }
            if hasCreateTime {
                try codedOutputStream.writeInt64(fieldNumber: 18, value:createTime)
            }
            if hasAddress {
                try codedOutputStream.writeString(fieldNumber: 19, value:address)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOrderId {
                serialize_size += orderId.computeStringSize(fieldNumber: 1)
            }
            if hasSymbol {
                serialize_size += symbol.computeStringSize(fieldNumber: 2)
            }
            if hasTradeTokenSymbol {
                serialize_size += tradeTokenSymbol.computeStringSize(fieldNumber: 3)
            }
            if hasQuoteTokenSymbol {
                serialize_size += quoteTokenSymbol.computeStringSize(fieldNumber: 4)
            }
            if hasTradeToken {
                serialize_size += tradeToken.computeStringSize(fieldNumber: 5)
            }
            if hasQuoteToken {
                serialize_size += quoteToken.computeStringSize(fieldNumber: 6)
            }
            if hasSide {
                serialize_size += side.computeInt32Size(fieldNumber: 7)
            }
            if hasPrice {
                serialize_size += price.computeStringSize(fieldNumber: 8)
            }
            if hasQuantity {
                serialize_size += quantity.computeStringSize(fieldNumber: 9)
            }
            if hasAmount {
                serialize_size += amount.computeStringSize(fieldNumber: 10)
            }
            if hasExecutedQuantity {
                serialize_size += executedQuantity.computeStringSize(fieldNumber: 11)
            }
            if hasExecutedAmount {
                serialize_size += executedAmount.computeStringSize(fieldNumber: 12)
            }
            if hasExecutedPercent {
                serialize_size += executedPercent.computeStringSize(fieldNumber: 13)
            }
            if hasExecutedAvgPrice {
                serialize_size += executedAvgPrice.computeStringSize(fieldNumber: 14)
            }
            if hasFee {
                serialize_size += fee.computeStringSize(fieldNumber: 15)
            }
            if hasStatus {
                serialize_size += status.computeInt32Size(fieldNumber: 16)
            }
            if hasType {
                serialize_size += type.computeInt32Size(fieldNumber: 17)
            }
            if hasCreateTime {
                serialize_size += createTime.computeInt64Size(fieldNumber: 18)
            }
            if hasAddress {
                serialize_size += address.computeStringSize(fieldNumber: 19)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Protocol.OrderProto.Builder {
            return Protocol.OrderProto.classBuilder() as! Protocol.OrderProto.Builder
        }
        public func getBuilder() -> Protocol.OrderProto.Builder {
            return classBuilder() as! Protocol.OrderProto.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Protocol.OrderProto.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Protocol.OrderProto.Builder()
        }
        public func toBuilder() throws -> Protocol.OrderProto.Builder {
            return try Protocol.OrderProto.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Protocol.OrderProto) throws -> Protocol.OrderProto.Builder {
            return try Protocol.OrderProto.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOrderId {
                jsonMap["orderId"] = orderId
            }
            if hasSymbol {
                jsonMap["symbol"] = symbol
            }
            if hasTradeTokenSymbol {
                jsonMap["tradeTokenSymbol"] = tradeTokenSymbol
            }
            if hasQuoteTokenSymbol {
                jsonMap["quoteTokenSymbol"] = quoteTokenSymbol
            }
            if hasTradeToken {
                jsonMap["tradeToken"] = tradeToken
            }
            if hasQuoteToken {
                jsonMap["quoteToken"] = quoteToken
            }
            if hasSide {
                jsonMap["side"] = Int(side)
            }
            if hasPrice {
                jsonMap["price"] = price
            }
            if hasQuantity {
                jsonMap["quantity"] = quantity
            }
            if hasAmount {
                jsonMap["amount"] = amount
            }
            if hasExecutedQuantity {
                jsonMap["executedQuantity"] = executedQuantity
            }
            if hasExecutedAmount {
                jsonMap["executedAmount"] = executedAmount
            }
            if hasExecutedPercent {
                jsonMap["executedPercent"] = executedPercent
            }
            if hasExecutedAvgPrice {
                jsonMap["executedAvgPrice"] = executedAvgPrice
            }
            if hasFee {
                jsonMap["fee"] = fee
            }
            if hasStatus {
                jsonMap["status"] = Int(status)
            }
            if hasType {
                jsonMap["type"] = Int(type)
            }
            if hasCreateTime {
                jsonMap["createTime"] = "\(createTime!)"
            }
            if hasAddress {
                jsonMap["address"] = address
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Protocol.OrderProto {
            return try Protocol.OrderProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Protocol.OrderProto {
            return try Protocol.OrderProto.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOrderId {
                output += "\(indent) orderId: \(String(describing: orderId)) \n"
            }
            if hasSymbol {
                output += "\(indent) symbol: \(String(describing: symbol)) \n"
            }
            if hasTradeTokenSymbol {
                output += "\(indent) tradeTokenSymbol: \(String(describing: tradeTokenSymbol)) \n"
            }
            if hasQuoteTokenSymbol {
                output += "\(indent) quoteTokenSymbol: \(String(describing: quoteTokenSymbol)) \n"
            }
            if hasTradeToken {
                output += "\(indent) tradeToken: \(String(describing: tradeToken)) \n"
            }
            if hasQuoteToken {
                output += "\(indent) quoteToken: \(String(describing: quoteToken)) \n"
            }
            if hasSide {
                output += "\(indent) side: \(String(describing: side)) \n"
            }
            if hasPrice {
                output += "\(indent) price: \(String(describing: price)) \n"
            }
            if hasQuantity {
                output += "\(indent) quantity: \(String(describing: quantity)) \n"
            }
            if hasAmount {
                output += "\(indent) amount: \(String(describing: amount)) \n"
            }
            if hasExecutedQuantity {
                output += "\(indent) executedQuantity: \(String(describing: executedQuantity)) \n"
            }
            if hasExecutedAmount {
                output += "\(indent) executedAmount: \(String(describing: executedAmount)) \n"
            }
            if hasExecutedPercent {
                output += "\(indent) executedPercent: \(String(describing: executedPercent)) \n"
            }
            if hasExecutedAvgPrice {
                output += "\(indent) executedAvgPrice: \(String(describing: executedAvgPrice)) \n"
            }
            if hasFee {
                output += "\(indent) fee: \(String(describing: fee)) \n"
            }
            if hasStatus {
                output += "\(indent) status: \(String(describing: status)) \n"
            }
            if hasType {
                output += "\(indent) type: \(String(describing: type)) \n"
            }
            if hasCreateTime {
                output += "\(indent) createTime: \(String(describing: createTime)) \n"
            }
            if hasAddress {
                output += "\(indent) address: \(String(describing: address)) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOrderId {
                    hashCode = (hashCode &* 31) &+ orderId.hashValue
                }
                if hasSymbol {
                    hashCode = (hashCode &* 31) &+ symbol.hashValue
                }
                if hasTradeTokenSymbol {
                    hashCode = (hashCode &* 31) &+ tradeTokenSymbol.hashValue
                }
                if hasQuoteTokenSymbol {
                    hashCode = (hashCode &* 31) &+ quoteTokenSymbol.hashValue
                }
                if hasTradeToken {
                    hashCode = (hashCode &* 31) &+ tradeToken.hashValue
                }
                if hasQuoteToken {
                    hashCode = (hashCode &* 31) &+ quoteToken.hashValue
                }
                if hasSide {
                    hashCode = (hashCode &* 31) &+ side.hashValue
                }
                if hasPrice {
                    hashCode = (hashCode &* 31) &+ price.hashValue
                }
                if hasQuantity {
                    hashCode = (hashCode &* 31) &+ quantity.hashValue
                }
                if hasAmount {
                    hashCode = (hashCode &* 31) &+ amount.hashValue
                }
                if hasExecutedQuantity {
                    hashCode = (hashCode &* 31) &+ executedQuantity.hashValue
                }
                if hasExecutedAmount {
                    hashCode = (hashCode &* 31) &+ executedAmount.hashValue
                }
                if hasExecutedPercent {
                    hashCode = (hashCode &* 31) &+ executedPercent.hashValue
                }
                if hasExecutedAvgPrice {
                    hashCode = (hashCode &* 31) &+ executedAvgPrice.hashValue
                }
                if hasFee {
                    hashCode = (hashCode &* 31) &+ fee.hashValue
                }
                if hasStatus {
                    hashCode = (hashCode &* 31) &+ status.hashValue
                }
                if hasType {
                    hashCode = (hashCode &* 31) &+ type.hashValue
                }
                if hasCreateTime {
                    hashCode = (hashCode &* 31) &+ createTime.hashValue
                }
                if hasAddress {
                    hashCode = (hashCode &* 31) &+ address.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Protocol.OrderProto"
        }
        override public func className() -> String {
            return "Protocol.OrderProto"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Protocol.OrderProto = Protocol.OrderProto()
            public func getMessage() -> Protocol.OrderProto {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///订单ID
            public var orderId:String {
                get {
                    return builderResult.orderId
                }
                set (value) {
                    builderResult.hasOrderId = true
                    builderResult.orderId = value
                }
            }
            public var hasOrderId:Bool {
                get {
                    return builderResult.hasOrderId
                }
            }
            @discardableResult
            public func setOrderId(_ value:String) -> Protocol.OrderProto.Builder {
                self.orderId = value
                return self
            }
            @discardableResult
            public func clearOrderId() -> Protocol.OrderProto.Builder{
                builderResult.hasOrderId = false
                builderResult.orderId = nil
                return self
            }
            ///symbol
            public var symbol:String {
                get {
                    return builderResult.symbol
                }
                set (value) {
                    builderResult.hasSymbol = true
                    builderResult.symbol = value
                }
            }
            public var hasSymbol:Bool {
                get {
                    return builderResult.hasSymbol
                }
            }
            @discardableResult
            public func setSymbol(_ value:String) -> Protocol.OrderProto.Builder {
                self.symbol = value
                return self
            }
            @discardableResult
            public func clearSymbol() -> Protocol.OrderProto.Builder{
                builderResult.hasSymbol = false
                builderResult.symbol = nil
                return self
            }
            ///symbol
            public var tradeTokenSymbol:String {
                get {
                    return builderResult.tradeTokenSymbol
                }
                set (value) {
                    builderResult.hasTradeTokenSymbol = true
                    builderResult.tradeTokenSymbol = value
                }
            }
            public var hasTradeTokenSymbol:Bool {
                get {
                    return builderResult.hasTradeTokenSymbol
                }
            }
            @discardableResult
            public func setTradeTokenSymbol(_ value:String) -> Protocol.OrderProto.Builder {
                self.tradeTokenSymbol = value
                return self
            }
            @discardableResult
            public func clearTradeTokenSymbol() -> Protocol.OrderProto.Builder{
                builderResult.hasTradeTokenSymbol = false
                builderResult.tradeTokenSymbol = nil
                return self
            }
            ///symbol
            public var quoteTokenSymbol:String {
                get {
                    return builderResult.quoteTokenSymbol
                }
                set (value) {
                    builderResult.hasQuoteTokenSymbol = true
                    builderResult.quoteTokenSymbol = value
                }
            }
            public var hasQuoteTokenSymbol:Bool {
                get {
                    return builderResult.hasQuoteTokenSymbol
                }
            }
            @discardableResult
            public func setQuoteTokenSymbol(_ value:String) -> Protocol.OrderProto.Builder {
                self.quoteTokenSymbol = value
                return self
            }
            @discardableResult
            public func clearQuoteTokenSymbol() -> Protocol.OrderProto.Builder{
                builderResult.hasQuoteTokenSymbol = false
                builderResult.quoteTokenSymbol = nil
                return self
            }
            ///tokenId
            public var tradeToken:String {
                get {
                    return builderResult.tradeToken
                }
                set (value) {
                    builderResult.hasTradeToken = true
                    builderResult.tradeToken = value
                }
            }
            public var hasTradeToken:Bool {
                get {
                    return builderResult.hasTradeToken
                }
            }
            @discardableResult
            public func setTradeToken(_ value:String) -> Protocol.OrderProto.Builder {
                self.tradeToken = value
                return self
            }
            @discardableResult
            public func clearTradeToken() -> Protocol.OrderProto.Builder{
                builderResult.hasTradeToken = false
                builderResult.tradeToken = nil
                return self
            }
            ///tokenId
            public var quoteToken:String {
                get {
                    return builderResult.quoteToken
                }
                set (value) {
                    builderResult.hasQuoteToken = true
                    builderResult.quoteToken = value
                }
            }
            public var hasQuoteToken:Bool {
                get {
                    return builderResult.hasQuoteToken
                }
            }
            @discardableResult
            public func setQuoteToken(_ value:String) -> Protocol.OrderProto.Builder {
                self.quoteToken = value
                return self
            }
            @discardableResult
            public func clearQuoteToken() -> Protocol.OrderProto.Builder{
                builderResult.hasQuoteToken = false
                builderResult.quoteToken = nil
                return self
            }
            ///方向
            public var side:Int32 {
                get {
                    return builderResult.side
                }
                set (value) {
                    builderResult.hasSide = true
                    builderResult.side = value
                }
            }
            public var hasSide:Bool {
                get {
                    return builderResult.hasSide
                }
            }
            @discardableResult
            public func setSide(_ value:Int32) -> Protocol.OrderProto.Builder {
                self.side = value
                return self
            }
            @discardableResult
            public func clearSide() -> Protocol.OrderProto.Builder{
                builderResult.hasSide = false
                builderResult.side = nil
                return self
            }
            ///价格
            public var price:String {
                get {
                    return builderResult.price
                }
                set (value) {
                    builderResult.hasPrice = true
                    builderResult.price = value
                }
            }
            public var hasPrice:Bool {
                get {
                    return builderResult.hasPrice
                }
            }
            @discardableResult
            public func setPrice(_ value:String) -> Protocol.OrderProto.Builder {
                self.price = value
                return self
            }
            @discardableResult
            public func clearPrice() -> Protocol.OrderProto.Builder{
                builderResult.hasPrice = false
                builderResult.price = nil
                return self
            }
            ///数量
            public var quantity:String {
                get {
                    return builderResult.quantity
                }
                set (value) {
                    builderResult.hasQuantity = true
                    builderResult.quantity = value
                }
            }
            public var hasQuantity:Bool {
                get {
                    return builderResult.hasQuantity
                }
            }
            @discardableResult
            public func setQuantity(_ value:String) -> Protocol.OrderProto.Builder {
                self.quantity = value
                return self
            }
            @discardableResult
            public func clearQuantity() -> Protocol.OrderProto.Builder{
                builderResult.hasQuantity = false
                builderResult.quantity = nil
                return self
            }
            ///交易量
            public var amount:String {
                get {
                    return builderResult.amount
                }
                set (value) {
                    builderResult.hasAmount = true
                    builderResult.amount = value
                }
            }
            public var hasAmount:Bool {
                get {
                    return builderResult.hasAmount
                }
            }
            @discardableResult
            public func setAmount(_ value:String) -> Protocol.OrderProto.Builder {
                self.amount = value
                return self
            }
            @discardableResult
            public func clearAmount() -> Protocol.OrderProto.Builder{
                builderResult.hasAmount = false
                builderResult.amount = nil
                return self
            }
            ///成交Quantity
            public var executedQuantity:String {
                get {
                    return builderResult.executedQuantity
                }
                set (value) {
                    builderResult.hasExecutedQuantity = true
                    builderResult.executedQuantity = value
                }
            }
            public var hasExecutedQuantity:Bool {
                get {
                    return builderResult.hasExecutedQuantity
                }
            }
            @discardableResult
            public func setExecutedQuantity(_ value:String) -> Protocol.OrderProto.Builder {
                self.executedQuantity = value
                return self
            }
            @discardableResult
            public func clearExecutedQuantity() -> Protocol.OrderProto.Builder{
                builderResult.hasExecutedQuantity = false
                builderResult.executedQuantity = nil
                return self
            }
            ///成交Amount
            public var executedAmount:String {
                get {
                    return builderResult.executedAmount
                }
                set (value) {
                    builderResult.hasExecutedAmount = true
                    builderResult.executedAmount = value
                }
            }
            public var hasExecutedAmount:Bool {
                get {
                    return builderResult.hasExecutedAmount
                }
            }
            @discardableResult
            public func setExecutedAmount(_ value:String) -> Protocol.OrderProto.Builder {
                self.executedAmount = value
                return self
            }
            @discardableResult
            public func clearExecutedAmount() -> Protocol.OrderProto.Builder{
                builderResult.hasExecutedAmount = false
                builderResult.executedAmount = nil
                return self
            }
            ///成交率
            public var executedPercent:String {
                get {
                    return builderResult.executedPercent
                }
                set (value) {
                    builderResult.hasExecutedPercent = true
                    builderResult.executedPercent = value
                }
            }
            public var hasExecutedPercent:Bool {
                get {
                    return builderResult.hasExecutedPercent
                }
            }
            @discardableResult
            public func setExecutedPercent(_ value:String) -> Protocol.OrderProto.Builder {
                self.executedPercent = value
                return self
            }
            @discardableResult
            public func clearExecutedPercent() -> Protocol.OrderProto.Builder{
                builderResult.hasExecutedPercent = false
                builderResult.executedPercent = nil
                return self
            }
            ///均价
            public var executedAvgPrice:String {
                get {
                    return builderResult.executedAvgPrice
                }
                set (value) {
                    builderResult.hasExecutedAvgPrice = true
                    builderResult.executedAvgPrice = value
                }
            }
            public var hasExecutedAvgPrice:Bool {
                get {
                    return builderResult.hasExecutedAvgPrice
                }
            }
            @discardableResult
            public func setExecutedAvgPrice(_ value:String) -> Protocol.OrderProto.Builder {
                self.executedAvgPrice = value
                return self
            }
            @discardableResult
            public func clearExecutedAvgPrice() -> Protocol.OrderProto.Builder{
                builderResult.hasExecutedAvgPrice = false
                builderResult.executedAvgPrice = nil
                return self
            }
            ///手续费
            public var fee:String {
                get {
                    return builderResult.fee
                }
                set (value) {
                    builderResult.hasFee = true
                    builderResult.fee = value
                }
            }
            public var hasFee:Bool {
                get {
                    return builderResult.hasFee
                }
            }
            @discardableResult
            public func setFee(_ value:String) -> Protocol.OrderProto.Builder {
                self.fee = value
                return self
            }
            @discardableResult
            public func clearFee() -> Protocol.OrderProto.Builder{
                builderResult.hasFee = false
                builderResult.fee = nil
                return self
            }
            ///状态
            public var status:Int32 {
                get {
                    return builderResult.status
                }
                set (value) {
                    builderResult.hasStatus = true
                    builderResult.status = value
                }
            }
            public var hasStatus:Bool {
                get {
                    return builderResult.hasStatus
                }
            }
            @discardableResult
            public func setStatus(_ value:Int32) -> Protocol.OrderProto.Builder {
                self.status = value
                return self
            }
            @discardableResult
            public func clearStatus() -> Protocol.OrderProto.Builder{
                builderResult.hasStatus = false
                builderResult.status = nil
                return self
            }
            ///类型
            public var type:Int32 {
                get {
                    return builderResult.type
                }
                set (value) {
                    builderResult.hasType = true
                    builderResult.type = value
                }
            }
            public var hasType:Bool {
                get {
                    return builderResult.hasType
                }
            }
            @discardableResult
            public func setType(_ value:Int32) -> Protocol.OrderProto.Builder {
                self.type = value
                return self
            }
            @discardableResult
            public func clearType() -> Protocol.OrderProto.Builder{
                builderResult.hasType = false
                builderResult.type = nil
                return self
            }
            ///时间
            public var createTime:Int64 {
                get {
                    return builderResult.createTime
                }
                set (value) {
                    builderResult.hasCreateTime = true
                    builderResult.createTime = value
                }
            }
            public var hasCreateTime:Bool {
                get {
                    return builderResult.hasCreateTime
                }
            }
            @discardableResult
            public func setCreateTime(_ value:Int64) -> Protocol.OrderProto.Builder {
                self.createTime = value
                return self
            }
            @discardableResult
            public func clearCreateTime() -> Protocol.OrderProto.Builder{
                builderResult.hasCreateTime = false
                builderResult.createTime = nil
                return self
            }
            ///地址
            public var address:String {
                get {
                    return builderResult.address
                }
                set (value) {
                    builderResult.hasAddress = true
                    builderResult.address = value
                }
            }
            public var hasAddress:Bool {
                get {
                    return builderResult.hasAddress
                }
            }
            @discardableResult
            public func setAddress(_ value:String) -> Protocol.OrderProto.Builder {
                self.address = value
                return self
            }
            @discardableResult
            public func clearAddress() -> Protocol.OrderProto.Builder{
                builderResult.hasAddress = false
                builderResult.address = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Protocol.OrderProto.Builder {
                builderResult = Protocol.OrderProto()
                return self
            }
            override public func clone() throws -> Protocol.OrderProto.Builder {
                return try Protocol.OrderProto.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Protocol.OrderProto {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Protocol.OrderProto {
                let returnMe:Protocol.OrderProto = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Protocol.OrderProto) throws -> Protocol.OrderProto.Builder {
                if other == Protocol.OrderProto() {
                    return self
                }
                if other.hasOrderId {
                    orderId = other.orderId
                }
                if other.hasSymbol {
                    symbol = other.symbol
                }
                if other.hasTradeTokenSymbol {
                    tradeTokenSymbol = other.tradeTokenSymbol
                }
                if other.hasQuoteTokenSymbol {
                    quoteTokenSymbol = other.quoteTokenSymbol
                }
                if other.hasTradeToken {
                    tradeToken = other.tradeToken
                }
                if other.hasQuoteToken {
                    quoteToken = other.quoteToken
                }
                if other.hasSide {
                    side = other.side
                }
                if other.hasPrice {
                    price = other.price
                }
                if other.hasQuantity {
                    quantity = other.quantity
                }
                if other.hasAmount {
                    amount = other.amount
                }
                if other.hasExecutedQuantity {
                    executedQuantity = other.executedQuantity
                }
                if other.hasExecutedAmount {
                    executedAmount = other.executedAmount
                }
                if other.hasExecutedPercent {
                    executedPercent = other.executedPercent
                }
                if other.hasExecutedAvgPrice {
                    executedAvgPrice = other.executedAvgPrice
                }
                if other.hasFee {
                    fee = other.fee
                }
                if other.hasStatus {
                    status = other.status
                }
                if other.hasType {
                    type = other.type
                }
                if other.hasCreateTime {
                    createTime = other.createTime
                }
                if other.hasAddress {
                    address = other.address
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Protocol.OrderProto.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.OrderProto.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        orderId = try codedInputStream.readString()

                    case 18:
                        symbol = try codedInputStream.readString()

                    case 26:
                        tradeTokenSymbol = try codedInputStream.readString()

                    case 34:
                        quoteTokenSymbol = try codedInputStream.readString()

                    case 42:
                        tradeToken = try codedInputStream.readString()

                    case 50:
                        quoteToken = try codedInputStream.readString()

                    case 56:
                        side = try codedInputStream.readInt32()

                    case 66:
                        price = try codedInputStream.readString()

                    case 74:
                        quantity = try codedInputStream.readString()

                    case 82:
                        amount = try codedInputStream.readString()

                    case 90:
                        executedQuantity = try codedInputStream.readString()

                    case 98:
                        executedAmount = try codedInputStream.readString()

                    case 106:
                        executedPercent = try codedInputStream.readString()

                    case 114:
                        executedAvgPrice = try codedInputStream.readString()

                    case 122:
                        fee = try codedInputStream.readString()

                    case 128:
                        status = try codedInputStream.readInt32()

                    case 136:
                        type = try codedInputStream.readInt32()

                    case 144:
                        createTime = try codedInputStream.readInt64()

                    case 154:
                        address = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Protocol.OrderProto.Builder {
                let resultDecodedBuilder = Protocol.OrderProto.Builder()
                if let jsonValueOrderId = jsonMap["orderId"] as? String {
                    resultDecodedBuilder.orderId = jsonValueOrderId
                }
                if let jsonValueSymbol = jsonMap["symbol"] as? String {
                    resultDecodedBuilder.symbol = jsonValueSymbol
                }
                if let jsonValueTradeTokenSymbol = jsonMap["tradeTokenSymbol"] as? String {
                    resultDecodedBuilder.tradeTokenSymbol = jsonValueTradeTokenSymbol
                }
                if let jsonValueQuoteTokenSymbol = jsonMap["quoteTokenSymbol"] as? String {
                    resultDecodedBuilder.quoteTokenSymbol = jsonValueQuoteTokenSymbol
                }
                if let jsonValueTradeToken = jsonMap["tradeToken"] as? String {
                    resultDecodedBuilder.tradeToken = jsonValueTradeToken
                }
                if let jsonValueQuoteToken = jsonMap["quoteToken"] as? String {
                    resultDecodedBuilder.quoteToken = jsonValueQuoteToken
                }
                if let jsonValueSide = jsonMap["side"] as? Int {
                    resultDecodedBuilder.side = Int32(jsonValueSide)
                } else if let jsonValueSide = jsonMap["side"] as? String {
                    resultDecodedBuilder.side = Int32(jsonValueSide)!
                }
                if let jsonValuePrice = jsonMap["price"] as? String {
                    resultDecodedBuilder.price = jsonValuePrice
                }
                if let jsonValueQuantity = jsonMap["quantity"] as? String {
                    resultDecodedBuilder.quantity = jsonValueQuantity
                }
                if let jsonValueAmount = jsonMap["amount"] as? String {
                    resultDecodedBuilder.amount = jsonValueAmount
                }
                if let jsonValueExecutedQuantity = jsonMap["executedQuantity"] as? String {
                    resultDecodedBuilder.executedQuantity = jsonValueExecutedQuantity
                }
                if let jsonValueExecutedAmount = jsonMap["executedAmount"] as? String {
                    resultDecodedBuilder.executedAmount = jsonValueExecutedAmount
                }
                if let jsonValueExecutedPercent = jsonMap["executedPercent"] as? String {
                    resultDecodedBuilder.executedPercent = jsonValueExecutedPercent
                }
                if let jsonValueExecutedAvgPrice = jsonMap["executedAvgPrice"] as? String {
                    resultDecodedBuilder.executedAvgPrice = jsonValueExecutedAvgPrice
                }
                if let jsonValueFee = jsonMap["fee"] as? String {
                    resultDecodedBuilder.fee = jsonValueFee
                }
                if let jsonValueStatus = jsonMap["status"] as? Int {
                    resultDecodedBuilder.status = Int32(jsonValueStatus)
                } else if let jsonValueStatus = jsonMap["status"] as? String {
                    resultDecodedBuilder.status = Int32(jsonValueStatus)!
                }
                if let jsonValueType = jsonMap["type"] as? Int {
                    resultDecodedBuilder.type = Int32(jsonValueType)
                } else if let jsonValueType = jsonMap["type"] as? String {
                    resultDecodedBuilder.type = Int32(jsonValueType)!
                }
                if let jsonValueCreateTime = jsonMap["createTime"] as? String {
                    resultDecodedBuilder.createTime = Int64(jsonValueCreateTime)!
                } else if let jsonValueCreateTime = jsonMap["createTime"] as? Int {
                    resultDecodedBuilder.createTime = Int64(jsonValueCreateTime)
                }
                if let jsonValueAddress = jsonMap["address"] as? String {
                    resultDecodedBuilder.address = jsonValueAddress
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Protocol.OrderProto.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Protocol.OrderProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DepthListProto : GeneratedMessage {
        public typealias BuilderType = Protocol.DepthListProto.Builder

        public static func == (lhs: Protocol.DepthListProto, rhs: Protocol.DepthListProto) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.asks == rhs.asks)
            fieldCheck = fieldCheck && (lhs.bids == rhs.bids)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var asks:Array<Protocol.DepthProto>  = Array<Protocol.DepthProto>()
        public fileprivate(set) var bids:Array<Protocol.DepthProto>  = Array<Protocol.DepthProto>()
        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementAsks in asks {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementAsks)
            }
            for oneElementBids in bids {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementBids)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementAsks in asks {
                serialize_size += oneElementAsks.computeMessageSize(fieldNumber: 1)
            }
            for oneElementBids in bids {
                serialize_size += oneElementBids.computeMessageSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Protocol.DepthListProto.Builder {
            return Protocol.DepthListProto.classBuilder() as! Protocol.DepthListProto.Builder
        }
        public func getBuilder() -> Protocol.DepthListProto.Builder {
            return classBuilder() as! Protocol.DepthListProto.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Protocol.DepthListProto.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Protocol.DepthListProto.Builder()
        }
        public func toBuilder() throws -> Protocol.DepthListProto.Builder {
            return try Protocol.DepthListProto.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Protocol.DepthListProto) throws -> Protocol.DepthListProto.Builder {
            return try Protocol.DepthListProto.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !asks.isEmpty {
                var jsonArrayAsks:Array<Dictionary<String,Any>> = []
                for oneValueAsks in asks {
                    let ecodedMessageAsks = try oneValueAsks.encode()
                    jsonArrayAsks.append(ecodedMessageAsks)
                }
                jsonMap["asks"] = jsonArrayAsks
            }
            if !bids.isEmpty {
                var jsonArrayBids:Array<Dictionary<String,Any>> = []
                for oneValueBids in bids {
                    let ecodedMessageBids = try oneValueBids.encode()
                    jsonArrayBids.append(ecodedMessageBids)
                }
                jsonMap["bids"] = jsonArrayBids
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Protocol.DepthListProto {
            return try Protocol.DepthListProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Protocol.DepthListProto {
            return try Protocol.DepthListProto.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var asksElementIndex:Int = 0
            for oneElementAsks in asks {
                output += "\(indent) asks[\(asksElementIndex)] {\n"
                output += try oneElementAsks.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                asksElementIndex += 1
            }
            var bidsElementIndex:Int = 0
            for oneElementBids in bids {
                output += "\(indent) bids[\(bidsElementIndex)] {\n"
                output += try oneElementBids.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                bidsElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementAsks in asks {
                    hashCode = (hashCode &* 31) &+ oneElementAsks.hashValue
                }
                for oneElementBids in bids {
                    hashCode = (hashCode &* 31) &+ oneElementBids.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Protocol.DepthListProto"
        }
        override public func className() -> String {
            return "Protocol.DepthListProto"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Protocol.DepthListProto = Protocol.DepthListProto()
            public func getMessage() -> Protocol.DepthListProto {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var asks:Array<Protocol.DepthProto> {
                get {
                    return builderResult.asks
                }
                set (value) {
                    builderResult.asks = value
                }
            }
            @discardableResult
            public func setAsks(_ value:Array<Protocol.DepthProto>) -> Protocol.DepthListProto.Builder {
                self.asks = value
                return self
            }
            @discardableResult
            public func clearAsks() -> Protocol.DepthListProto.Builder {
                builderResult.asks.removeAll(keepingCapacity: false)
                return self
            }
            public var bids:Array<Protocol.DepthProto> {
                get {
                    return builderResult.bids
                }
                set (value) {
                    builderResult.bids = value
                }
            }
            @discardableResult
            public func setBids(_ value:Array<Protocol.DepthProto>) -> Protocol.DepthListProto.Builder {
                self.bids = value
                return self
            }
            @discardableResult
            public func clearBids() -> Protocol.DepthListProto.Builder {
                builderResult.bids.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Protocol.DepthListProto.Builder {
                builderResult = Protocol.DepthListProto()
                return self
            }
            override public func clone() throws -> Protocol.DepthListProto.Builder {
                return try Protocol.DepthListProto.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Protocol.DepthListProto {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Protocol.DepthListProto {
                let returnMe:Protocol.DepthListProto = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Protocol.DepthListProto) throws -> Protocol.DepthListProto.Builder {
                if other == Protocol.DepthListProto() {
                    return self
                }
                if !other.asks.isEmpty  {
                     builderResult.asks += other.asks
                }
                if !other.bids.isEmpty  {
                     builderResult.bids += other.bids
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Protocol.DepthListProto.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.DepthListProto.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Protocol.DepthProto.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        asks.append(subBuilder.buildPartial())

                    case 18:
                        let subBuilder = Protocol.DepthProto.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        bids.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Protocol.DepthListProto.Builder {
                let resultDecodedBuilder = Protocol.DepthListProto.Builder()
                if let jsonValueAsks = jsonMap["asks"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayAsks:Array<Protocol.DepthProto> = []
                    for oneValueAsks in jsonValueAsks {
                        let messageFromStringAsks = try Protocol.DepthProto.Builder.decodeToBuilder(jsonMap:oneValueAsks).build()

                        jsonArrayAsks.append(messageFromStringAsks)
                    }
                    resultDecodedBuilder.asks = jsonArrayAsks
                }
                if let jsonValueBids = jsonMap["bids"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayBids:Array<Protocol.DepthProto> = []
                    for oneValueBids in jsonValueBids {
                        let messageFromStringBids = try Protocol.DepthProto.Builder.decodeToBuilder(jsonMap:oneValueBids).build()

                        jsonArrayBids.append(messageFromStringBids)
                    }
                    resultDecodedBuilder.bids = jsonArrayBids
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Protocol.DepthListProto.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Protocol.DepthListProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DepthProto : GeneratedMessage {
        public typealias BuilderType = Protocol.DepthProto.Builder

        public static func == (lhs: Protocol.DepthProto, rhs: Protocol.DepthProto) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasPrice == rhs.hasPrice) && (!lhs.hasPrice || lhs.price == rhs.price)
            fieldCheck = fieldCheck && (lhs.hasQuantity == rhs.hasQuantity) && (!lhs.hasQuantity || lhs.quantity == rhs.quantity)
            fieldCheck = fieldCheck && (lhs.hasAmount == rhs.hasAmount) && (!lhs.hasAmount || lhs.amount == rhs.amount)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///价格
        public fileprivate(set) var price:String! = nil
        public fileprivate(set) var hasPrice:Bool = false

        ///数量
        public fileprivate(set) var quantity:String! = nil
        public fileprivate(set) var hasQuantity:Bool = false

        ///交易量
        public fileprivate(set) var amount:String! = nil
        public fileprivate(set) var hasAmount:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() throws {
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasPrice {
                try codedOutputStream.writeString(fieldNumber: 1, value:price)
            }
            if hasQuantity {
                try codedOutputStream.writeString(fieldNumber: 2, value:quantity)
            }
            if hasAmount {
                try codedOutputStream.writeString(fieldNumber: 3, value:amount)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasPrice {
                serialize_size += price.computeStringSize(fieldNumber: 1)
            }
            if hasQuantity {
                serialize_size += quantity.computeStringSize(fieldNumber: 2)
            }
            if hasAmount {
                serialize_size += amount.computeStringSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Protocol.DepthProto.Builder {
            return Protocol.DepthProto.classBuilder() as! Protocol.DepthProto.Builder
        }
        public func getBuilder() -> Protocol.DepthProto.Builder {
            return classBuilder() as! Protocol.DepthProto.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Protocol.DepthProto.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Protocol.DepthProto.Builder()
        }
        public func toBuilder() throws -> Protocol.DepthProto.Builder {
            return try Protocol.DepthProto.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Protocol.DepthProto) throws -> Protocol.DepthProto.Builder {
            return try Protocol.DepthProto.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            try isInitialized()
            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasPrice {
                jsonMap["price"] = price
            }
            if hasQuantity {
                jsonMap["quantity"] = quantity
            }
            if hasAmount {
                jsonMap["amount"] = amount
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Protocol.DepthProto {
            return try Protocol.DepthProto.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Protocol.DepthProto {
            return try Protocol.DepthProto.Builder.fromJSONToBuilder(data:data, options:options).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasPrice {
                output += "\(indent) price: \(String(describing: price)) \n"
            }
            if hasQuantity {
                output += "\(indent) quantity: \(String(describing: quantity)) \n"
            }
            if hasAmount {
                output += "\(indent) amount: \(String(describing: amount)) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasPrice {
                    hashCode = (hashCode &* 31) &+ price.hashValue
                }
                if hasQuantity {
                    hashCode = (hashCode &* 31) &+ quantity.hashValue
                }
                if hasAmount {
                    hashCode = (hashCode &* 31) &+ amount.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Protocol.DepthProto"
        }
        override public func className() -> String {
            return "Protocol.DepthProto"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Protocol.DepthProto = Protocol.DepthProto()
            public func getMessage() -> Protocol.DepthProto {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///价格
            public var price:String {
                get {
                    return builderResult.price
                }
                set (value) {
                    builderResult.hasPrice = true
                    builderResult.price = value
                }
            }
            public var hasPrice:Bool {
                get {
                    return builderResult.hasPrice
                }
            }
            @discardableResult
            public func setPrice(_ value:String) -> Protocol.DepthProto.Builder {
                self.price = value
                return self
            }
            @discardableResult
            public func clearPrice() -> Protocol.DepthProto.Builder{
                builderResult.hasPrice = false
                builderResult.price = nil
                return self
            }
            ///数量
            public var quantity:String {
                get {
                    return builderResult.quantity
                }
                set (value) {
                    builderResult.hasQuantity = true
                    builderResult.quantity = value
                }
            }
            public var hasQuantity:Bool {
                get {
                    return builderResult.hasQuantity
                }
            }
            @discardableResult
            public func setQuantity(_ value:String) -> Protocol.DepthProto.Builder {
                self.quantity = value
                return self
            }
            @discardableResult
            public func clearQuantity() -> Protocol.DepthProto.Builder{
                builderResult.hasQuantity = false
                builderResult.quantity = nil
                return self
            }
            ///交易量
            public var amount:String {
                get {
                    return builderResult.amount
                }
                set (value) {
                    builderResult.hasAmount = true
                    builderResult.amount = value
                }
            }
            public var hasAmount:Bool {
                get {
                    return builderResult.hasAmount
                }
            }
            @discardableResult
            public func setAmount(_ value:String) -> Protocol.DepthProto.Builder {
                self.amount = value
                return self
            }
            @discardableResult
            public func clearAmount() -> Protocol.DepthProto.Builder{
                builderResult.hasAmount = false
                builderResult.amount = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Protocol.DepthProto.Builder {
                builderResult = Protocol.DepthProto()
                return self
            }
            override public func clone() throws -> Protocol.DepthProto.Builder {
                return try Protocol.DepthProto.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Protocol.DepthProto {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Protocol.DepthProto {
                let returnMe:Protocol.DepthProto = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Protocol.DepthProto) throws -> Protocol.DepthProto.Builder {
                if other == Protocol.DepthProto() {
                    return self
                }
                if other.hasPrice {
                    price = other.price
                }
                if other.hasQuantity {
                    quantity = other.quantity
                }
                if other.hasAmount {
                    amount = other.amount
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Protocol.DepthProto.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.DepthProto.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        price = try codedInputStream.readString()

                    case 18:
                        quantity = try codedInputStream.readString()

                    case 26:
                        amount = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Protocol.DepthProto.Builder {
                let resultDecodedBuilder = Protocol.DepthProto.Builder()
                if let jsonValuePrice = jsonMap["price"] as? String {
                    resultDecodedBuilder.price = jsonValuePrice
                }
                if let jsonValueQuantity = jsonMap["quantity"] as? String {
                    resultDecodedBuilder.quantity = jsonValueQuantity
                }
                if let jsonValueAmount = jsonMap["amount"] as? String {
                    resultDecodedBuilder.amount = jsonValueAmount
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data, options: JSONSerialization.ReadingOptions = []) throws -> Protocol.DepthProto.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: options)
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Protocol.DepthProto.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Protocol.DexProtocol: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Protocol.DexProtocol> {
        var mergedArray = Array<Protocol.DexProtocol>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Protocol.DexProtocol? {
        return try Protocol.DexProtocol.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Protocol.DexProtocol {
        return try Protocol.DexProtocol.Builder().mergeFrom(data: data, extensionRegistry:Protocol.MarketRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Protocol.DexProtocol {
        return try Protocol.DexProtocol.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Protocol.DexProtocol {
        return try Protocol.DexProtocol.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.DexProtocol {
        return try Protocol.DexProtocol.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Protocol.DexProtocol {
        return try Protocol.DexProtocol.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.DexProtocol {
        return try Protocol.DexProtocol.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "clientId": return self.clientId
        case "topics": return self.topics
        case "opType": return self.opType
        case "message": return self.message
        case "errorCode": return self.errorCode
        default: return nil
        }
    }
}
extension Protocol.DexProtocol.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Protocol.DexProtocol
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "clientId": return self.clientId
            case "topics": return self.topics
            case "opType": return self.opType
            case "message": return self.message
            case "errorCode": return self.errorCode
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "clientId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.clientId = newSubscriptValue
            case "topics":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.topics = newSubscriptValue
            case "opType":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.opType = newSubscriptValue
            case "message":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.message = newSubscriptValue
            case "errorCode":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.errorCode = newSubscriptValue
            default: return
            }
        }
    }
}
extension Protocol.TickerStatisticsProto: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Protocol.TickerStatisticsProto> {
        var mergedArray = Array<Protocol.TickerStatisticsProto>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Protocol.TickerStatisticsProto? {
        return try Protocol.TickerStatisticsProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Protocol.TickerStatisticsProto {
        return try Protocol.TickerStatisticsProto.Builder().mergeFrom(data: data, extensionRegistry:Protocol.MarketRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Protocol.TickerStatisticsProto {
        return try Protocol.TickerStatisticsProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Protocol.TickerStatisticsProto {
        return try Protocol.TickerStatisticsProto.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.TickerStatisticsProto {
        return try Protocol.TickerStatisticsProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Protocol.TickerStatisticsProto {
        return try Protocol.TickerStatisticsProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.TickerStatisticsProto {
        return try Protocol.TickerStatisticsProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "symbol": return self.symbol
        case "tradeTokenSymbol": return self.tradeTokenSymbol
        case "quoteTokenSymbol": return self.quoteTokenSymbol
        case "tradeToken": return self.tradeToken
        case "quoteToken": return self.quoteToken
        case "openPrice": return self.openPrice
        case "prevClosePrice": return self.prevClosePrice
        case "closePrice": return self.closePrice
        case "priceChange": return self.priceChange
        case "priceChangePercent": return self.priceChangePercent
        case "highPrice": return self.highPrice
        case "lowPrice": return self.lowPrice
        case "quantity": return self.quantity
        case "amount": return self.amount
        case "pricePrecision": return self.pricePrecision
        case "quantityPrecision": return self.quantityPrecision
        default: return nil
        }
    }
}
extension Protocol.TickerStatisticsProto.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Protocol.TickerStatisticsProto
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "symbol": return self.symbol
            case "tradeTokenSymbol": return self.tradeTokenSymbol
            case "quoteTokenSymbol": return self.quoteTokenSymbol
            case "tradeToken": return self.tradeToken
            case "quoteToken": return self.quoteToken
            case "openPrice": return self.openPrice
            case "prevClosePrice": return self.prevClosePrice
            case "closePrice": return self.closePrice
            case "priceChange": return self.priceChange
            case "priceChangePercent": return self.priceChangePercent
            case "highPrice": return self.highPrice
            case "lowPrice": return self.lowPrice
            case "quantity": return self.quantity
            case "amount": return self.amount
            case "pricePrecision": return self.pricePrecision
            case "quantityPrecision": return self.quantityPrecision
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "symbol":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.symbol = newSubscriptValue
            case "tradeTokenSymbol":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.tradeTokenSymbol = newSubscriptValue
            case "quoteTokenSymbol":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.quoteTokenSymbol = newSubscriptValue
            case "tradeToken":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.tradeToken = newSubscriptValue
            case "quoteToken":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.quoteToken = newSubscriptValue
            case "openPrice":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.openPrice = newSubscriptValue
            case "prevClosePrice":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.prevClosePrice = newSubscriptValue
            case "closePrice":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.closePrice = newSubscriptValue
            case "priceChange":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.priceChange = newSubscriptValue
            case "priceChangePercent":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.priceChangePercent = newSubscriptValue
            case "highPrice":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.highPrice = newSubscriptValue
            case "lowPrice":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.lowPrice = newSubscriptValue
            case "quantity":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.quantity = newSubscriptValue
            case "amount":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.amount = newSubscriptValue
            case "pricePrecision":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.pricePrecision = newSubscriptValue
            case "quantityPrecision":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.quantityPrecision = newSubscriptValue
            default: return
            }
        }
    }
}
extension Protocol.TradeListProto: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Protocol.TradeListProto> {
        var mergedArray = Array<Protocol.TradeListProto>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Protocol.TradeListProto? {
        return try Protocol.TradeListProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Protocol.TradeListProto {
        return try Protocol.TradeListProto.Builder().mergeFrom(data: data, extensionRegistry:Protocol.MarketRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Protocol.TradeListProto {
        return try Protocol.TradeListProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Protocol.TradeListProto {
        return try Protocol.TradeListProto.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.TradeListProto {
        return try Protocol.TradeListProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Protocol.TradeListProto {
        return try Protocol.TradeListProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.TradeListProto {
        return try Protocol.TradeListProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "trade": return self.trade
        default: return nil
        }
    }
}
extension Protocol.TradeListProto.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Protocol.TradeListProto
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "trade": return self.trade
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "trade":
                guard let newSubscriptValue = newSubscriptValue as? Array<Protocol.TradeProto> else {
                    return
                }
                self.trade = newSubscriptValue
            default: return
            }
        }
    }
}
extension Protocol.TradeProto: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Protocol.TradeProto> {
        var mergedArray = Array<Protocol.TradeProto>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Protocol.TradeProto? {
        return try Protocol.TradeProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Protocol.TradeProto {
        return try Protocol.TradeProto.Builder().mergeFrom(data: data, extensionRegistry:Protocol.MarketRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Protocol.TradeProto {
        return try Protocol.TradeProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Protocol.TradeProto {
        return try Protocol.TradeProto.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.TradeProto {
        return try Protocol.TradeProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Protocol.TradeProto {
        return try Protocol.TradeProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.TradeProto {
        return try Protocol.TradeProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "tradeId": return self.tradeId
        case "symbol": return self.symbol
        case "tradeTokenSymbol": return self.tradeTokenSymbol
        case "quoteTokenSymbol": return self.quoteTokenSymbol
        case "tradeToken": return self.tradeToken
        case "quoteToken": return self.quoteToken
        case "price": return self.price
        case "quantity": return self.quantity
        case "amount": return self.amount
        case "time": return self.time
        case "side": return self.side
        case "buyerOrderId": return self.buyerOrderId
        case "sellerOrderId": return self.sellerOrderId
        case "buyFee": return self.buyFee
        case "sellFee": return self.sellFee
        case "blockHeight": return self.blockHeight
        default: return nil
        }
    }
}
extension Protocol.TradeProto.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Protocol.TradeProto
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "tradeId": return self.tradeId
            case "symbol": return self.symbol
            case "tradeTokenSymbol": return self.tradeTokenSymbol
            case "quoteTokenSymbol": return self.quoteTokenSymbol
            case "tradeToken": return self.tradeToken
            case "quoteToken": return self.quoteToken
            case "price": return self.price
            case "quantity": return self.quantity
            case "amount": return self.amount
            case "time": return self.time
            case "side": return self.side
            case "buyerOrderId": return self.buyerOrderId
            case "sellerOrderId": return self.sellerOrderId
            case "buyFee": return self.buyFee
            case "sellFee": return self.sellFee
            case "blockHeight": return self.blockHeight
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "tradeId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.tradeId = newSubscriptValue
            case "symbol":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.symbol = newSubscriptValue
            case "tradeTokenSymbol":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.tradeTokenSymbol = newSubscriptValue
            case "quoteTokenSymbol":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.quoteTokenSymbol = newSubscriptValue
            case "tradeToken":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.tradeToken = newSubscriptValue
            case "quoteToken":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.quoteToken = newSubscriptValue
            case "price":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.price = newSubscriptValue
            case "quantity":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.quantity = newSubscriptValue
            case "amount":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.amount = newSubscriptValue
            case "time":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.time = newSubscriptValue
            case "side":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.side = newSubscriptValue
            case "buyerOrderId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.buyerOrderId = newSubscriptValue
            case "sellerOrderId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sellerOrderId = newSubscriptValue
            case "buyFee":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.buyFee = newSubscriptValue
            case "sellFee":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sellFee = newSubscriptValue
            case "blockHeight":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.blockHeight = newSubscriptValue
            default: return
            }
        }
    }
}
extension Protocol.KlineProto: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Protocol.KlineProto> {
        var mergedArray = Array<Protocol.KlineProto>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Protocol.KlineProto? {
        return try Protocol.KlineProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Protocol.KlineProto {
        return try Protocol.KlineProto.Builder().mergeFrom(data: data, extensionRegistry:Protocol.MarketRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Protocol.KlineProto {
        return try Protocol.KlineProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Protocol.KlineProto {
        return try Protocol.KlineProto.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.KlineProto {
        return try Protocol.KlineProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Protocol.KlineProto {
        return try Protocol.KlineProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.KlineProto {
        return try Protocol.KlineProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "t": return self.t
        case "c": return self.c
        case "o": return self.o
        case "h": return self.h
        case "l": return self.l
        case "v": return self.v
        default: return nil
        }
    }
}
extension Protocol.KlineProto.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Protocol.KlineProto
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "t": return self.t
            case "c": return self.c
            case "o": return self.o
            case "h": return self.h
            case "l": return self.l
            case "v": return self.v
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "t":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.t = newSubscriptValue
            case "c":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.c = newSubscriptValue
            case "o":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.o = newSubscriptValue
            case "h":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.h = newSubscriptValue
            case "l":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.l = newSubscriptValue
            case "v":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.v = newSubscriptValue
            default: return
            }
        }
    }
}
extension Protocol.OrderProto: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Protocol.OrderProto> {
        var mergedArray = Array<Protocol.OrderProto>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Protocol.OrderProto? {
        return try Protocol.OrderProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Protocol.OrderProto {
        return try Protocol.OrderProto.Builder().mergeFrom(data: data, extensionRegistry:Protocol.MarketRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Protocol.OrderProto {
        return try Protocol.OrderProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Protocol.OrderProto {
        return try Protocol.OrderProto.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.OrderProto {
        return try Protocol.OrderProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Protocol.OrderProto {
        return try Protocol.OrderProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.OrderProto {
        return try Protocol.OrderProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "orderId": return self.orderId
        case "symbol": return self.symbol
        case "tradeTokenSymbol": return self.tradeTokenSymbol
        case "quoteTokenSymbol": return self.quoteTokenSymbol
        case "tradeToken": return self.tradeToken
        case "quoteToken": return self.quoteToken
        case "side": return self.side
        case "price": return self.price
        case "quantity": return self.quantity
        case "amount": return self.amount
        case "executedQuantity": return self.executedQuantity
        case "executedAmount": return self.executedAmount
        case "executedPercent": return self.executedPercent
        case "executedAvgPrice": return self.executedAvgPrice
        case "fee": return self.fee
        case "status": return self.status
        case "type": return self.type
        case "createTime": return self.createTime
        case "address": return self.address
        default: return nil
        }
    }
}
extension Protocol.OrderProto.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Protocol.OrderProto
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "orderId": return self.orderId
            case "symbol": return self.symbol
            case "tradeTokenSymbol": return self.tradeTokenSymbol
            case "quoteTokenSymbol": return self.quoteTokenSymbol
            case "tradeToken": return self.tradeToken
            case "quoteToken": return self.quoteToken
            case "side": return self.side
            case "price": return self.price
            case "quantity": return self.quantity
            case "amount": return self.amount
            case "executedQuantity": return self.executedQuantity
            case "executedAmount": return self.executedAmount
            case "executedPercent": return self.executedPercent
            case "executedAvgPrice": return self.executedAvgPrice
            case "fee": return self.fee
            case "status": return self.status
            case "type": return self.type
            case "createTime": return self.createTime
            case "address": return self.address
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "orderId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.orderId = newSubscriptValue
            case "symbol":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.symbol = newSubscriptValue
            case "tradeTokenSymbol":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.tradeTokenSymbol = newSubscriptValue
            case "quoteTokenSymbol":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.quoteTokenSymbol = newSubscriptValue
            case "tradeToken":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.tradeToken = newSubscriptValue
            case "quoteToken":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.quoteToken = newSubscriptValue
            case "side":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.side = newSubscriptValue
            case "price":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.price = newSubscriptValue
            case "quantity":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.quantity = newSubscriptValue
            case "amount":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.amount = newSubscriptValue
            case "executedQuantity":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.executedQuantity = newSubscriptValue
            case "executedAmount":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.executedAmount = newSubscriptValue
            case "executedPercent":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.executedPercent = newSubscriptValue
            case "executedAvgPrice":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.executedAvgPrice = newSubscriptValue
            case "fee":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.fee = newSubscriptValue
            case "status":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.status = newSubscriptValue
            case "type":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.type = newSubscriptValue
            case "createTime":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.createTime = newSubscriptValue
            case "address":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.address = newSubscriptValue
            default: return
            }
        }
    }
}
extension Protocol.DepthListProto: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Protocol.DepthListProto> {
        var mergedArray = Array<Protocol.DepthListProto>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Protocol.DepthListProto? {
        return try Protocol.DepthListProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Protocol.DepthListProto {
        return try Protocol.DepthListProto.Builder().mergeFrom(data: data, extensionRegistry:Protocol.MarketRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Protocol.DepthListProto {
        return try Protocol.DepthListProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Protocol.DepthListProto {
        return try Protocol.DepthListProto.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.DepthListProto {
        return try Protocol.DepthListProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Protocol.DepthListProto {
        return try Protocol.DepthListProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.DepthListProto {
        return try Protocol.DepthListProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "asks": return self.asks
        case "bids": return self.bids
        default: return nil
        }
    }
}
extension Protocol.DepthListProto.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Protocol.DepthListProto
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "asks": return self.asks
            case "bids": return self.bids
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "asks":
                guard let newSubscriptValue = newSubscriptValue as? Array<Protocol.DepthProto> else {
                    return
                }
                self.asks = newSubscriptValue
            case "bids":
                guard let newSubscriptValue = newSubscriptValue as? Array<Protocol.DepthProto> else {
                    return
                }
                self.bids = newSubscriptValue
            default: return
            }
        }
    }
}
extension Protocol.DepthProto: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Protocol.DepthProto> {
        var mergedArray = Array<Protocol.DepthProto>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Protocol.DepthProto? {
        return try Protocol.DepthProto.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Protocol.DepthProto {
        return try Protocol.DepthProto.Builder().mergeFrom(data: data, extensionRegistry:Protocol.MarketRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Protocol.DepthProto {
        return try Protocol.DepthProto.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Protocol.DepthProto {
        return try Protocol.DepthProto.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.DepthProto {
        return try Protocol.DepthProto.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Protocol.DepthProto {
        return try Protocol.DepthProto.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Protocol.DepthProto {
        return try Protocol.DepthProto.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "price": return self.price
        case "quantity": return self.quantity
        case "amount": return self.amount
        default: return nil
        }
    }
}
extension Protocol.DepthProto.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Protocol.DepthProto
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "price": return self.price
            case "quantity": return self.quantity
            case "amount": return self.amount
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "price":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.price = newSubscriptValue
            case "quantity":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.quantity = newSubscriptValue
            case "amount":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.amount = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
